=begin
#Linstor REST API

#Linstor REST API V1  The V1 rest api of Linstor should stay compatible and only additions are made to the API, If there are breaking changes or redesigned a new major REST API version will be issued.  Server runs per default on port `3370` on `::` ipv6 and ipv4.  To change the bind address or port you can use the following linstor client commands: ``` linstor controller set-property REST/bindAddress 127.0.0.1 linstor controller set-property REST/port 8080 ```  After setting this properties restart the controller and the new values should be used.  Changelog:  * 1.0.13   - Fixed broken volume definition modify `flags` handling   - Added flags to volume groups (create/modify) * 1.0.12   - Added WritecacheResource and WritecacheVolume schemas.   - Removed support for swordfish   - Added `with_storage_pool` to PhysicalStorageCreate post request, allowing to create linstor storage pools too   - Added `gross` flag for volume-definition size   - Added flags to VolumeDefinitionModify (so that `gross` flag can be changed)   - Added query-max-volume-size to resource-groups * 1.0.11   - Added /v1/physical-storage endpoint, that lets you query and create lvm/zfs pools   - Extended Node with list of supported providers and layers as well as lists of reasons for     unsupported providers and layers * 1.0.10   - Added `reports` array field to Volume object, contains ApiCallRcs for problems   - Changed `ResourceDefinitions` can now include `VolumeDefinitions` in `volume_definitions` field   - Added various filter query parameters * 1.0.9   - Added supports_snapshots to StoragePool * 1.0.8   - Added /v1/resource-groups   - Added /v1/resource-groups/{rscgrp}/volume-groups   - Moved AutoSelectFilter::place_count default indirectly to create resource implementation   - Added diskless_on_remaining to AutoSelectFilter   - Changed /v1/view/resources return type to ResourceWithVolumes     ResourceWithVolumes is now a child type of Resource (removed volumes from Resource) * 1.0.7   - Added ext_meta_stor_pool to DrbdVolume   - Added is_active field to the NetInterface type * 1.0.6   - Added /v1/resource-definitions/{rscName}/resources/{nodeName}/volumes/{vlmnr} PUT * 1.0.5   - Added `reports` field to StoragePool object * 1.0.4   - Added /v1/view/storage-pools overview path   - Added uuid fields for objects * 1.0.3   - Added /v1/view/resources overview path   - documentation schema extraction * 1.0.2   - Added /v1/storage-pool-definitions object path   - added NVME layer object type * 1.0.1   - Documentation review and updates   - no functional changes * 1.0.0   - Initial REST API v1 

The version of the OpenAPI document: 1.0.13
Contact: rene.peinthor@linbit.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.3.1

=end

require 'cgi'

module LinstorClient
  class DevelopersApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Deletes a controller property
    # Delete a controller property
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def controller_property_delete(key, opts = {})
      data, _status_code, _headers = controller_property_delete_with_http_info(key, opts)
      data
    end

    # Deletes a controller property
    # Delete a controller property
    # @param key [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def controller_property_delete_with_http_info(key, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.controller_property_delete ...'
      end
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        fail ArgumentError, "Missing the required parameter 'key' when calling DevelopersApi.controller_property_delete"
      end
      # resource path
      local_var_path = '/v1/controller/properties/{key}'.sub('{' + 'key' + '}', CGI.escape(key.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.controller_property_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#controller_property_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all controller properties
    # Lists all controller properties. 
    # @param [Hash] opts the optional parameters
    # @return [Hash<String, String>]
    def controller_property_list(opts = {})
      data, _status_code, _headers = controller_property_list_with_http_info(opts)
      data
    end

    # lists all controller properties
    # Lists all controller properties. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Hash<String, String>, Integer, Hash)>] Hash<String, String> data, response status code and response headers
    def controller_property_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.controller_property_list ...'
      end
      # resource path
      local_var_path = '/v1/controller/properties'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, String>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.controller_property_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#controller_property_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # sets or modifies controller properties
    # Sets or modifies properties  Possible properties are: - `TcpPortAutoRange` - regex[`[0-9]+-[0-9]+`]      Range for auto-allocation of resource TCP ports  - `MinorNrAutoRange` - regex[`[0-9]+-[0-9]+`]      Range for auto-allocation of volume minor numbers  - `PeerSlotsNewResource` - range[`1-31`]      DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future  - `StorDriver/DMStats` - boolean_true_false      Enable dmstats on lvm create  - `GlobSeqApiCalls` - boolean_true_false      Globally sequentialize all ctrl -> stlt api calls  - `REST/bindAddress` - string      Bind address of the REST API  - `REST/port` - range[`1-65535`]      TCP Port of the REST API  - `REST/enabled` - boolean_true_false      Bool if REST API should be enabled  - `NVMe/enabled` - enum     * rdma     * tcp  - `NVMe/enabled` - range[`1-65535`] - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Preferred network interface to use  - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`] - `sys/fs/blkio_throttle_read` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - `sys/fs/blkio_throttle_write` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - `SearchDomain` - string      Search domain node names, if no FQDN is given.  - `ExtCmdWaitTimeout` - long      Wait timeout for an external command in milliseconds  - `DrbdOptions/auto-quorum` - enum      Enables automatic setting of the 'quroum' and 'on-no-quroum' property      * io-error     * suspend-io     * disabled  - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false      Enables automatic management (creation and deletion) of tie breaking resource  - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name for writecache  - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]      Size of the writecache in % (0-100) or KiB otherwise  - `Writecache/Blocksize` - long      4096 is recommended; the maximum block size is the page size  - `Writecache/Options/StartSector` - long      offset from the start of cache device in 512-byte sectors  - `Writecache/Options/HighWatermark` - long      start writeback when the number of used blocks reach this watermark  - `Writecache/Options/LowWatermark` - long      stop writeback when the number of used blocks drops below this watermark  - `Writecache/Options/WritebackJobs` - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - `Writecache/Options/AutocommitBlocks` - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - `Writecache/Options/AutocommitTime` - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - `Writecache/Options/Fua` - enum      \"On\" results in \"fua\" as argument, whereas the value \"Off\" results in \"nofua\" argument      * On     * Off  - `Writecache/Options/Additional` - string      Additional arguments passed through  - `DrbdOptions/Disk/read-balancing` - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - `DrbdOptions/Disk/on-io-error` - enum     * pass_on     * call-local-io-error     * detach  - `DrbdOptions/Disk/disk-drain` - boolean - `DrbdOptions/Disk/resync-after` - string - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`] - `DrbdOptions/Disk/disable-write-same` - boolean - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`] - `DrbdOptions/Disk/disk-flushes` - boolean - `DrbdOptions/Disk/al-extents` - range[`67-65534`] - `DrbdOptions/Disk/al-updates` - boolean - `DrbdOptions/Disk/md-flushes` - boolean - `DrbdOptions/Disk/disk-barrier` - boolean - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`] - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`] - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`] - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`] - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`] - `DrbdOptions/PeerDevice/bitmap` - boolean - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`] - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`] - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]     * off     * majority     * all  - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`] - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`] - `DrbdOptions/Resource/quorum` - enum [`1-32`]     * off     * majority     * all  - `DrbdOptions/Resource/on-no-data-accessible` - enum     * io-error     * suspend-io  - `DrbdOptions/Resource/auto-promote` - boolean - `DrbdOptions/Resource/cpu-mask` - string - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`] - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`] - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`] - `DrbdOptions/Resource/on-no-quorum` - enum     * io-error     * suspend-io  - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`] - `DrbdOptions/Net/protocol` - enum     * A     * B     * C  - `DrbdOptions/Net/allow-two-primaries` - boolean - `DrbdOptions/Net/after-sb-0pri` - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - `DrbdOptions/Net/ko-count` - range[`0-200`] - `DrbdOptions/Net/data-integrity-alg` - string - `DrbdOptions/Net/ping-timeout` - range[`1-300`] - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/transport` - string - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/max-buffers` - range[`32-131072`] - `DrbdOptions/Net/fencing` - enum     * dont-care     * resource-only     * resource-and-stonith  - `DrbdOptions/Net/csums-alg` - string - `DrbdOptions/Net/always-asbp` - boolean - `DrbdOptions/Net/congestion-extents` - range[`67-65534`] - `DrbdOptions/Net/on-congestion` - enum     * block     * pull-ahead     * disconnect  - `DrbdOptions/Net/ping-int` - range[`1-120`] - `DrbdOptions/Net/rr-conflict` - enum     * disconnect     * call-pri-lost     * violently  - `DrbdOptions/Net/tcp-cork` - boolean - `DrbdOptions/Net/use-rle` - boolean - `DrbdOptions/Net/csums-after-crash-only` - boolean - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`] - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`] - `DrbdOptions/Net/cram-hmac-alg` - string - `DrbdOptions/Net/verify-alg` - string - `DrbdOptions/Net/shared-secret` - string - `DrbdOptions/Net/connect-int` - range[`1-120`] - `DrbdOptions/Net/timeout` - range[`1-600`] - `DrbdOptions/Net/after-sb-2pri` - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Net/after-sb-1pri` - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Handlers/after-resync-target` - string - `DrbdOptions/Handlers/before-resync-target` - string - `DrbdOptions/Handlers/before-resync-source` - string - `DrbdOptions/Handlers/out-of-sync` - string - `DrbdOptions/Handlers/quorum-lost` - string - `DrbdOptions/Handlers/fence-peer` - string - `DrbdOptions/Handlers/unfence-peer` - string - `DrbdOptions/Handlers/initial-split-brain` - string - `DrbdOptions/Handlers/local-io-error` - string - `DrbdOptions/Handlers/pri-lost` - string - `DrbdOptions/Handlers/pri-lost-after-sb` - string - `DrbdOptions/Handlers/pri-on-incon-degr` - string - `DrbdOptions/Handlers/split-brain` - string 
    # @param [Hash] opts the optional parameters
    # @option opts [ControllerPropsModify] :controller_props_modify 
    # @return [ApiCallRc]
    def controller_property_modify(opts = {})
      data, _status_code, _headers = controller_property_modify_with_http_info(opts)
      data
    end

    # sets or modifies controller properties
    # Sets or modifies properties  Possible properties are: - &#x60;TcpPortAutoRange&#x60; - regex[&#x60;[0-9]+-[0-9]+&#x60;]      Range for auto-allocation of resource TCP ports  - &#x60;MinorNrAutoRange&#x60; - regex[&#x60;[0-9]+-[0-9]+&#x60;]      Range for auto-allocation of volume minor numbers  - &#x60;PeerSlotsNewResource&#x60; - range[&#x60;1-31&#x60;]      DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future  - &#x60;StorDriver/DMStats&#x60; - boolean_true_false      Enable dmstats on lvm create  - &#x60;GlobSeqApiCalls&#x60; - boolean_true_false      Globally sequentialize all ctrl -&gt; stlt api calls  - &#x60;REST/bindAddress&#x60; - string      Bind address of the REST API  - &#x60;REST/port&#x60; - range[&#x60;1-65535&#x60;]      TCP Port of the REST API  - &#x60;REST/enabled&#x60; - boolean_true_false      Bool if REST API should be enabled  - &#x60;NVMe/enabled&#x60; - enum     * rdma     * tcp  - &#x60;NVMe/enabled&#x60; - range[&#x60;1-65535&#x60;] - &#x60;NVMe/PrefNic&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Preferred network interface to use  - &#x60;StorDriver/WaitTimeoutAfterCreate&#x60; - regex[&#x60;[0-9]+&#x60;] - &#x60;sys/fs/blkio_throttle_read&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - &#x60;sys/fs/blkio_throttle_write&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - &#x60;SearchDomain&#x60; - string      Search domain node names, if no FQDN is given.  - &#x60;ExtCmdWaitTimeout&#x60; - long      Wait timeout for an external command in milliseconds  - &#x60;DrbdOptions/auto-quorum&#x60; - enum      Enables automatic setting of the &#39;quroum&#39; and &#39;on-no-quroum&#39; property      * io-error     * suspend-io     * disabled  - &#x60;DrbdOptions/auto-add-quorum-tiebreaker&#x60; - boolean_true_false      Enables automatic management (creation and deletion) of tie breaking resource  - &#x60;Writecache/PoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name for writecache  - &#x60;Writecache/Size&#x60; - regex[&#x60;^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$&#x60;]      Size of the writecache in % (0-100) or KiB otherwise  - &#x60;Writecache/Blocksize&#x60; - long      4096 is recommended; the maximum block size is the page size  - &#x60;Writecache/Options/StartSector&#x60; - long      offset from the start of cache device in 512-byte sectors  - &#x60;Writecache/Options/HighWatermark&#x60; - long      start writeback when the number of used blocks reach this watermark  - &#x60;Writecache/Options/LowWatermark&#x60; - long      stop writeback when the number of used blocks drops below this watermark  - &#x60;Writecache/Options/WritebackJobs&#x60; - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - &#x60;Writecache/Options/AutocommitBlocks&#x60; - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - &#x60;Writecache/Options/AutocommitTime&#x60; - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - &#x60;Writecache/Options/Fua&#x60; - enum      \&quot;On\&quot; results in \&quot;fua\&quot; as argument, whereas the value \&quot;Off\&quot; results in \&quot;nofua\&quot; argument      * On     * Off  - &#x60;Writecache/Options/Additional&#x60; - string      Additional arguments passed through  - &#x60;DrbdOptions/Disk/read-balancing&#x60; - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - &#x60;DrbdOptions/Disk/on-io-error&#x60; - enum     * pass_on     * call-local-io-error     * detach  - &#x60;DrbdOptions/Disk/disk-drain&#x60; - boolean - &#x60;DrbdOptions/Disk/resync-after&#x60; - string - &#x60;DrbdOptions/Disk/disk-timeout&#x60; - range[&#x60;0-6000&#x60;] - &#x60;DrbdOptions/Disk/disable-write-same&#x60; - boolean - &#x60;DrbdOptions/Disk/rs-discard-granularity&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/Disk/disk-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/al-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Disk/al-updates&#x60; - boolean - &#x60;DrbdOptions/Disk/md-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/disk-barrier&#x60; - boolean - &#x60;DrbdOptions/Disk/discard-zeroes-if-aligned&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-fill-target&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/PeerDevice/c-max-rate&#x60; - range[&#x60;250-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/resync-rate&#x60; - range[&#x60;1-8388608&#x60;] - &#x60;DrbdOptions/PeerDevice/c-delay-target&#x60; - range[&#x60;1-100&#x60;] - &#x60;DrbdOptions/PeerDevice/c-min-rate&#x60; - range[&#x60;0-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/bitmap&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-plan-ahead&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Resource/peer-ack-delay&#x60; - range[&#x60;1-10000&#x60;] - &#x60;DrbdOptions/Resource/quorum-minimum-redundancy&#x60; - enum [&#x60;1-32&#x60;]     * off     * majority     * all  - &#x60;DrbdOptions/Resource/max-io-depth&#x60; - range[&#x60;4-4294967295&#x60;] - &#x60;DrbdOptions/Resource/auto-promote-timeout&#x60; - range[&#x60;0-600&#x60;] - &#x60;DrbdOptions/Resource/quorum&#x60; - enum [&#x60;1-32&#x60;]     * off     * majority     * all  - &#x60;DrbdOptions/Resource/on-no-data-accessible&#x60; - enum     * io-error     * suspend-io  - &#x60;DrbdOptions/Resource/auto-promote&#x60; - boolean - &#x60;DrbdOptions/Resource/cpu-mask&#x60; - string - &#x60;DrbdOptions/Resource/twopc-timeout&#x60; - range[&#x60;50-600&#x60;] - &#x60;DrbdOptions/Resource/twopc-retry-timeout&#x60; - range[&#x60;1-50&#x60;] - &#x60;DrbdOptions/Resource/peer-ack-window&#x60; - range[&#x60;2048-204800&#x60;] - &#x60;DrbdOptions/Resource/on-no-quorum&#x60; - enum     * io-error     * suspend-io  - &#x60;DrbdOptions/Net/max-epoch-size&#x60; - range[&#x60;1-20000&#x60;] - &#x60;DrbdOptions/Net/protocol&#x60; - enum     * A     * B     * C  - &#x60;DrbdOptions/Net/allow-two-primaries&#x60; - boolean - &#x60;DrbdOptions/Net/after-sb-0pri&#x60; - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - &#x60;DrbdOptions/Net/ko-count&#x60; - range[&#x60;0-200&#x60;] - &#x60;DrbdOptions/Net/data-integrity-alg&#x60; - string - &#x60;DrbdOptions/Net/ping-timeout&#x60; - range[&#x60;1-300&#x60;] - &#x60;DrbdOptions/Net/sndbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/transport&#x60; - string - &#x60;DrbdOptions/Net/rcvbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/max-buffers&#x60; - range[&#x60;32-131072&#x60;] - &#x60;DrbdOptions/Net/fencing&#x60; - enum     * dont-care     * resource-only     * resource-and-stonith  - &#x60;DrbdOptions/Net/csums-alg&#x60; - string - &#x60;DrbdOptions/Net/always-asbp&#x60; - boolean - &#x60;DrbdOptions/Net/congestion-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Net/on-congestion&#x60; - enum     * block     * pull-ahead     * disconnect  - &#x60;DrbdOptions/Net/ping-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/rr-conflict&#x60; - enum     * disconnect     * call-pri-lost     * violently  - &#x60;DrbdOptions/Net/tcp-cork&#x60; - boolean - &#x60;DrbdOptions/Net/use-rle&#x60; - boolean - &#x60;DrbdOptions/Net/csums-after-crash-only&#x60; - boolean - &#x60;DrbdOptions/Net/socket-check-timeout&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Net/congestion-fill&#x60; - range[&#x60;0-20971520&#x60;] - &#x60;DrbdOptions/Net/cram-hmac-alg&#x60; - string - &#x60;DrbdOptions/Net/verify-alg&#x60; - string - &#x60;DrbdOptions/Net/shared-secret&#x60; - string - &#x60;DrbdOptions/Net/connect-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/timeout&#x60; - range[&#x60;1-600&#x60;] - &#x60;DrbdOptions/Net/after-sb-2pri&#x60; - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Net/after-sb-1pri&#x60; - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Handlers/after-resync-target&#x60; - string - &#x60;DrbdOptions/Handlers/before-resync-target&#x60; - string - &#x60;DrbdOptions/Handlers/before-resync-source&#x60; - string - &#x60;DrbdOptions/Handlers/out-of-sync&#x60; - string - &#x60;DrbdOptions/Handlers/quorum-lost&#x60; - string - &#x60;DrbdOptions/Handlers/fence-peer&#x60; - string - &#x60;DrbdOptions/Handlers/unfence-peer&#x60; - string - &#x60;DrbdOptions/Handlers/initial-split-brain&#x60; - string - &#x60;DrbdOptions/Handlers/local-io-error&#x60; - string - &#x60;DrbdOptions/Handlers/pri-lost&#x60; - string - &#x60;DrbdOptions/Handlers/pri-lost-after-sb&#x60; - string - &#x60;DrbdOptions/Handlers/pri-on-incon-degr&#x60; - string - &#x60;DrbdOptions/Handlers/split-brain&#x60; - string 
    # @param [Hash] opts the optional parameters
    # @option opts [ControllerPropsModify] :controller_props_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def controller_property_modify_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.controller_property_modify ...'
      end
      # resource path
      local_var_path = '/v1/controller/properties'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'controller_props_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.controller_property_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#controller_property_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # show controller version info
    # Show Controller version info 
    # @param [Hash] opts the optional parameters
    # @return [ControllerVersion]
    def controller_version(opts = {})
      data, _status_code, _headers = controller_version_with_http_info(opts)
      data
    end

    # show controller version info
    # Show Controller version info 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ControllerVersion, Integer, Hash)>] ControllerVersion data, response status code and response headers
    def controller_version_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.controller_version ...'
      end
      # resource path
      local_var_path = '/v1/controller/version'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ControllerVersion'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.controller_version",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#controller_version\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # creates an LVM, LVM-thin or ZFS pool, optional VDO under it
    # Creates a LVM/LVM-thin, ZFS pool on the given device and if supported VDO(optional) under it. logcal_size_kib parameter is only needed if LVM-thin or vdo is used is used. Also note VDO can only used with LVM-fat. 
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [PhysicalStorageCreate] :physical_storage_create 
    # @return [ApiCallRc]
    def create_device_pool(node, opts = {})
      data, _status_code, _headers = create_device_pool_with_http_info(node, opts)
      data
    end

    # creates an LVM, LVM-thin or ZFS pool, optional VDO under it
    # Creates a LVM/LVM-thin, ZFS pool on the given device and if supported VDO(optional) under it. logcal_size_kib parameter is only needed if LVM-thin or vdo is used is used. Also note VDO can only used with LVM-fat. 
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [PhysicalStorageCreate] :physical_storage_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def create_device_pool_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.create_device_pool ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.create_device_pool"
      end
      # resource path
      local_var_path = '/v1/physical-storage/{node}'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'physical_storage_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.create_device_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#create_device_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # create a encryption passphrase
    # @param [Hash] opts the optional parameters
    # @option opts [PassPhraseCreate] :pass_phrase_create 
    # @return [ApiCallRc]
    def encryption_passphrase_create(opts = {})
      data, _status_code, _headers = encryption_passphrase_create_with_http_info(opts)
      data
    end

    # create a encryption passphrase
    # @param [Hash] opts the optional parameters
    # @option opts [PassPhraseCreate] :pass_phrase_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def encryption_passphrase_create_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.encryption_passphrase_create ...'
      end
      # resource path
      local_var_path = '/v1/encryption/passphrase'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'pass_phrase_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.encryption_passphrase_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#encryption_passphrase_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # enter the encryption passphrase
    # @param [Hash] opts the optional parameters
    # @option opts [String] :body 
    # @return [ApiCallRc]
    def encryption_passphrase_enter(opts = {})
      data, _status_code, _headers = encryption_passphrase_enter_with_http_info(opts)
      data
    end

    # enter the encryption passphrase
    # @param [Hash] opts the optional parameters
    # @option opts [String] :body 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def encryption_passphrase_enter_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.encryption_passphrase_enter ...'
      end
      # resource path
      local_var_path = '/v1/encryption/passphrase'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.encryption_passphrase_enter",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#encryption_passphrase_enter\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modifies the encryption passphrase
    # @param [Hash] opts the optional parameters
    # @option opts [PassPhraseCreate] :pass_phrase_create 
    # @return [ApiCallRc]
    def encryption_passphrase_modify(opts = {})
      data, _status_code, _headers = encryption_passphrase_modify_with_http_info(opts)
      data
    end

    # modifies the encryption passphrase
    # @param [Hash] opts the optional parameters
    # @option opts [PassPhraseCreate] :pass_phrase_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def encryption_passphrase_modify_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.encryption_passphrase_modify ...'
      end
      # resource path
      local_var_path = '/v1/encryption/passphrase'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'pass_phrase_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.encryption_passphrase_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#encryption_passphrase_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # list all error reports
    # List all error reports
    # @param [Hash] opts the optional parameters
    # @option opts [String] :node Only show error reports of this node
    # @option opts [Integer] :since Unix timestamp from the starting interval
    # @option opts [Integer] :to Unix timestamp to the ending interval
    # @option opts [Boolean] :with_content Include error report text in response. (default to false)
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<ErrorReport>]
    def error_report_list(opts = {})
      data, _status_code, _headers = error_report_list_with_http_info(opts)
      data
    end

    # list all error reports
    # List all error reports
    # @param [Hash] opts the optional parameters
    # @option opts [String] :node Only show error reports of this node
    # @option opts [Integer] :since Unix timestamp from the starting interval
    # @option opts [Integer] :to Unix timestamp to the ending interval
    # @option opts [Boolean] :with_content Include error report text in response.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<ErrorReport>, Integer, Hash)>] Array<ErrorReport> data, response status code and response headers
    def error_report_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.error_report_list ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.error_report_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.error_report_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.error_report_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/error-reports'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'node'] = opts[:'node'] if !opts[:'node'].nil?
      query_params[:'since'] = opts[:'since'] if !opts[:'since'].nil?
      query_params[:'to'] = opts[:'to'] if !opts[:'to'].nil?
      query_params[:'withContent'] = opts[:'with_content'] if !opts[:'with_content'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ErrorReport>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.error_report_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#error_report_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # query the specified reportid
    # Query the specified reportid
    # @param reportid [String] Error id to select
    # @param [Hash] opts the optional parameters
    # @option opts [String] :node Only show error reports of this node
    # @option opts [Integer] :since Unix timestamp from the starting interval
    # @option opts [Integer] :to Unix timestamp to the ending interval
    # @option opts [Boolean] :with_content Include error report text in response. (default to true)
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<ErrorReport>]
    def error_report_show(reportid, opts = {})
      data, _status_code, _headers = error_report_show_with_http_info(reportid, opts)
      data
    end

    # query the specified reportid
    # Query the specified reportid
    # @param reportid [String] Error id to select
    # @param [Hash] opts the optional parameters
    # @option opts [String] :node Only show error reports of this node
    # @option opts [Integer] :since Unix timestamp from the starting interval
    # @option opts [Integer] :to Unix timestamp to the ending interval
    # @option opts [Boolean] :with_content Include error report text in response.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<ErrorReport>, Integer, Hash)>] Array<ErrorReport> data, response status code and response headers
    def error_report_show_with_http_info(reportid, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.error_report_show ...'
      end
      # verify the required parameter 'reportid' is set
      if @api_client.config.client_side_validation && reportid.nil?
        fail ArgumentError, "Missing the required parameter 'reportid' when calling DevelopersApi.error_report_show"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.error_report_show, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.error_report_show, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.error_report_show, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/error-reports/{reportid}'.sub('{' + 'reportid' + '}', CGI.escape(reportid.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'node'] = opts[:'node'] if !opts[:'node'].nil?
      query_params[:'since'] = opts[:'since'] if !opts[:'since'].nil?
      query_params[:'to'] = opts[:'to'] if !opts[:'to'].nil?
      query_params[:'withContent'] = opts[:'with_content'] if !opts[:'with_content'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ErrorReport>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.error_report_show",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#error_report_show\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a key value store
    # Delete a key value store
    # @param instance [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def key_value_store_delete(instance, opts = {})
      data, _status_code, _headers = key_value_store_delete_with_http_info(instance, opts)
      data
    end

    # delete a key value store
    # Delete a key value store
    # @param instance [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def key_value_store_delete_with_http_info(instance, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.key_value_store_delete ...'
      end
      # verify the required parameter 'instance' is set
      if @api_client.config.client_side_validation && instance.nil?
        fail ArgumentError, "Missing the required parameter 'instance' when calling DevelopersApi.key_value_store_delete"
      end
      # resource path
      local_var_path = '/v1/key-value-store/{instance}'.sub('{' + 'instance' + '}', CGI.escape(instance.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.key_value_store_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#key_value_store_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # list all key value stores
    # List all known key value store instances
    # @param instance [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<KeyValueStore>]
    def key_value_store_list(instance, opts = {})
      data, _status_code, _headers = key_value_store_list_with_http_info(instance, opts)
      data
    end

    # list all key value stores
    # List all known key value store instances
    # @param instance [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<KeyValueStore>, Integer, Hash)>] Array<KeyValueStore> data, response status code and response headers
    def key_value_store_list_with_http_info(instance, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.key_value_store_list ...'
      end
      # verify the required parameter 'instance' is set
      if @api_client.config.client_side_validation && instance.nil?
        fail ArgumentError, "Missing the required parameter 'instance' when calling DevelopersApi.key_value_store_list"
      end
      # resource path
      local_var_path = '/v1/key-value-store/{instance}'.sub('{' + 'instance' + '}', CGI.escape(instance.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<KeyValueStore>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.key_value_store_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#key_value_store_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a key value store
    # Modify a key value store
    # @param instance [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [KeyValueStoreModify] :key_value_store_modify 
    # @return [ApiCallRc]
    def key_value_store_modify(instance, opts = {})
      data, _status_code, _headers = key_value_store_modify_with_http_info(instance, opts)
      data
    end

    # modify a key value store
    # Modify a key value store
    # @param instance [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [KeyValueStoreModify] :key_value_store_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def key_value_store_modify_with_http_info(instance, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.key_value_store_modify ...'
      end
      # verify the required parameter 'instance' is set
      if @api_client.config.client_side_validation && instance.nil?
        fail ArgumentError, "Missing the required parameter 'instance' when calling DevelopersApi.key_value_store_modify"
      end
      # resource path
      local_var_path = '/v1/key-value-store/{instance}'.sub('{' + 'instance' + '}', CGI.escape(instance.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'key_value_store_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.key_value_store_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#key_value_store_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # list all key value stores
    # List all known key value store instances
    # @param [Hash] opts the optional parameters
    # @return [Array<KeyValueStore>]
    def key_value_stores_list(opts = {})
      data, _status_code, _headers = key_value_stores_list_with_http_info(opts)
      data
    end

    # list all key value stores
    # List all known key value store instances
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<KeyValueStore>, Integer, Hash)>] Array<KeyValueStore> data, response status code and response headers
    def key_value_stores_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.key_value_stores_list ...'
      end
      # resource path
      local_var_path = '/v1/key-value-store'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<KeyValueStore>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.key_value_stores_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#key_value_stores_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # create a netinterface on a node
    # Create a netinterface on a node  If satellite_port and satellite_encryption_type are given the netinterface can also work as connection to the controller 
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [NetInterface] :net_interface 
    # @return [ApiCallRc]
    def netinterface_create(node, opts = {})
      data, _status_code, _headers = netinterface_create_with_http_info(node, opts)
      data
    end

    # create a netinterface on a node
    # Create a netinterface on a node  If satellite_port and satellite_encryption_type are given the netinterface can also work as connection to the controller 
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [NetInterface] :net_interface 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def netinterface_create_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.netinterface_create ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.netinterface_create"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/net-interfaces'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'net_interface'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.netinterface_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#netinterface_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a netinterface from a node
    # Delete a netinterface from a node
    # @param node [String] node to use
    # @param netinterface [String] netinterface name to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def netinterface_delete(node, netinterface, opts = {})
      data, _status_code, _headers = netinterface_delete_with_http_info(node, netinterface, opts)
      data
    end

    # delete a netinterface from a node
    # Delete a netinterface from a node
    # @param node [String] node to use
    # @param netinterface [String] netinterface name to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def netinterface_delete_with_http_info(node, netinterface, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.netinterface_delete ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.netinterface_delete"
      end
      # verify the required parameter 'netinterface' is set
      if @api_client.config.client_side_validation && netinterface.nil?
        fail ArgumentError, "Missing the required parameter 'netinterface' when calling DevelopersApi.netinterface_delete"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/net-interfaces/{netinterface}'.sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'netinterface' + '}', CGI.escape(netinterface.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.netinterface_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#netinterface_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # return the list of net-interfaces
    # Returns the list of netinterfaces for this node
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<NetInterface>]
    def netinterface_list(node, opts = {})
      data, _status_code, _headers = netinterface_list_with_http_info(node, opts)
      data
    end

    # return the list of net-interfaces
    # Returns the list of netinterfaces for this node
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<NetInterface>, Integer, Hash)>] Array<NetInterface> data, response status code and response headers
    def netinterface_list_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.netinterface_list ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.netinterface_list"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.netinterface_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.netinterface_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.netinterface_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/nodes/{node}/net-interfaces'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<NetInterface>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.netinterface_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#netinterface_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a netinterface from a node
    # Modify a netinterface from a node
    # @param node [String] node to use
    # @param netinterface [String] netinterface name to use
    # @param [Hash] opts the optional parameters
    # @option opts [NetInterface] :net_interface 
    # @return [ApiCallRc]
    def netinterface_modified(node, netinterface, opts = {})
      data, _status_code, _headers = netinterface_modified_with_http_info(node, netinterface, opts)
      data
    end

    # modify a netinterface from a node
    # Modify a netinterface from a node
    # @param node [String] node to use
    # @param netinterface [String] netinterface name to use
    # @param [Hash] opts the optional parameters
    # @option opts [NetInterface] :net_interface 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def netinterface_modified_with_http_info(node, netinterface, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.netinterface_modified ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.netinterface_modified"
      end
      # verify the required parameter 'netinterface' is set
      if @api_client.config.client_side_validation && netinterface.nil?
        fail ArgumentError, "Missing the required parameter 'netinterface' when calling DevelopersApi.netinterface_modified"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/net-interfaces/{netinterface}'.sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'netinterface' + '}', CGI.escape(netinterface.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'net_interface'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.netinterface_modified",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#netinterface_modified\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # add a node to Linstor
    # Adds a node to Linstor  If only one net-interface is specified and it is does not specify a `satellite_port` it will apply the default port and `satellite_encryption_type` for this net-interface. 
    # @param [Hash] opts the optional parameters
    # @option opts [Node] :node Node to add to Linstor
    # @return [ApiCallRc]
    def node_add(opts = {})
      data, _status_code, _headers = node_add_with_http_info(opts)
      data
    end

    # add a node to Linstor
    # Adds a node to Linstor  If only one net-interface is specified and it is does not specify a &#x60;satellite_port&#x60; it will apply the default port and &#x60;satellite_encryption_type&#x60; for this net-interface. 
    # @param [Hash] opts the optional parameters
    # @option opts [Node] :node Node to add to Linstor
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_add_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_add ...'
      end
      # resource path
      local_var_path = '/v1/nodes'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'node'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_add",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_add\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a node
    # Delete a node from Linstor
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def node_delete(node, opts = {})
      data, _status_code, _headers = node_delete_with_http_info(node, opts)
      data
    end

    # delete a node
    # Delete a node from Linstor
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_delete_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_delete ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_delete"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Lists nodes registered to the controller
    # Returns an array of all nodes registered to Linstor. 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<Node>]
    def node_list(opts = {})
      data, _status_code, _headers = node_list_with_http_info(opts)
      data
    end

    # Lists nodes registered to the controller
    # Returns an array of all nodes registered to Linstor. 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<Node>, Integer, Hash)>] Array<Node> data, response status code and response headers
    def node_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_list ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.node_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.node_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.node_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/nodes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Node>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete an unrecoverable node
    # Delete an unrecoverable node
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def node_lost(node, opts = {})
      data, _status_code, _headers = node_lost_with_http_info(node, opts)
      data
    end

    # delete an unrecoverable node
    # Delete an unrecoverable node
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_lost_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_lost ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_lost"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/lost'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_lost",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_lost\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a node
    # Sets or modifies properties  Possible properties are: - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Preferred network interface to use  - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `DrbdMetaType` - enum     * external     * internal  - `sys/fs/blkio_throttle_read` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - `sys/fs/blkio_throttle_write` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name for writecache  - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]      Size of the writecache in % (0-100) or KiB otherwise  - `Writecache/Blocksize` - long      4096 is recommended; the maximum block size is the page size  - `Writecache/Options/StartSector` - long      offset from the start of cache device in 512-byte sectors  - `Writecache/Options/HighWatermark` - long      start writeback when the number of used blocks reach this watermark  - `Writecache/Options/LowWatermark` - long      stop writeback when the number of used blocks drops below this watermark  - `Writecache/Options/WritebackJobs` - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - `Writecache/Options/AutocommitBlocks` - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - `Writecache/Options/AutocommitTime` - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - `Writecache/Options/Fua` - enum      \"On\" results in \"fua\" as argument, whereas the value \"Off\" results in \"nofua\" argument      * On     * Off  - `Writecache/Options/Additional` - string      Additional arguments passed through  
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [NodeModify] :node_modify 
    # @return [ApiCallRc]
    def node_modify(node, opts = {})
      data, _status_code, _headers = node_modify_with_http_info(node, opts)
      data
    end

    # modify a node
    # Sets or modifies properties  Possible properties are: - &#x60;PrefNic&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Preferred network interface to use  - &#x60;StorPoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;StorPoolNameDrbdMeta&#x60; - regex[&#x60;^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;DrbdMetaType&#x60; - enum     * external     * internal  - &#x60;sys/fs/blkio_throttle_read&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - &#x60;sys/fs/blkio_throttle_write&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - &#x60;Writecache/PoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name for writecache  - &#x60;Writecache/Size&#x60; - regex[&#x60;^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$&#x60;]      Size of the writecache in % (0-100) or KiB otherwise  - &#x60;Writecache/Blocksize&#x60; - long      4096 is recommended; the maximum block size is the page size  - &#x60;Writecache/Options/StartSector&#x60; - long      offset from the start of cache device in 512-byte sectors  - &#x60;Writecache/Options/HighWatermark&#x60; - long      start writeback when the number of used blocks reach this watermark  - &#x60;Writecache/Options/LowWatermark&#x60; - long      stop writeback when the number of used blocks drops below this watermark  - &#x60;Writecache/Options/WritebackJobs&#x60; - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - &#x60;Writecache/Options/AutocommitBlocks&#x60; - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - &#x60;Writecache/Options/AutocommitTime&#x60; - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - &#x60;Writecache/Options/Fua&#x60; - enum      \&quot;On\&quot; results in \&quot;fua\&quot; as argument, whereas the value \&quot;Off\&quot; results in \&quot;nofua\&quot; argument      * On     * Off  - &#x60;Writecache/Options/Additional&#x60; - string      Additional arguments passed through  
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [NodeModify] :node_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_modify_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_modify ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_modify"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'node_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # reconnect a node to the controller
    # Reconnect a node to the controller
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def node_reconnect(node, opts = {})
      data, _status_code, _headers = node_reconnect_with_http_info(node, opts)
      data
    end

    # reconnect a node to the controller
    # Reconnect a node to the controller
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_reconnect_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_reconnect ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_reconnect"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/reconnect'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_reconnect",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_reconnect\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # creates a new storage pool on this node
    # Creates a new storage pool on this node.  `provider_kind` has to be specified and additional to that the linked `StorDriver` property that has the value to the backing pool:    * `LVM`: `StorDriver/LvmVg`   * `LVM_THIN`: `StorDriver/LvmVg` and `StorDriver/ThinPool`   * `ZFS`: `StorDriver/ZPool`   * `ZFS_THIN`: `StorDriver/ZPoolThin`   * `DISKLESS`: Does not need a property as it has no backing pool 
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePool] :storage_pool 
    # @return [ApiCallRc]
    def node_storage_pool_create(node, opts = {})
      data, _status_code, _headers = node_storage_pool_create_with_http_info(node, opts)
      data
    end

    # creates a new storage pool on this node
    # Creates a new storage pool on this node.  &#x60;provider_kind&#x60; has to be specified and additional to that the linked &#x60;StorDriver&#x60; property that has the value to the backing pool:    * &#x60;LVM&#x60;: &#x60;StorDriver/LvmVg&#x60;   * &#x60;LVM_THIN&#x60;: &#x60;StorDriver/LvmVg&#x60; and &#x60;StorDriver/ThinPool&#x60;   * &#x60;ZFS&#x60;: &#x60;StorDriver/ZPool&#x60;   * &#x60;ZFS_THIN&#x60;: &#x60;StorDriver/ZPoolThin&#x60;   * &#x60;DISKLESS&#x60;: Does not need a property as it has no backing pool 
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePool] :storage_pool 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_storage_pool_create_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_storage_pool_create ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_storage_pool_create"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/storage-pools'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'storage_pool'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_storage_pool_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_storage_pool_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a storage pool
    # Delete a storage pool
    # @param node [String] node to use
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def node_storage_pool_delete(node, storagepool, opts = {})
      data, _status_code, _headers = node_storage_pool_delete_with_http_info(node, storagepool, opts)
      data
    end

    # delete a storage pool
    # Delete a storage pool
    # @param node [String] node to use
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_storage_pool_delete_with_http_info(node, storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_storage_pool_delete ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_storage_pool_delete"
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.node_storage_pool_delete"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/storage-pools/{storagepool}'.sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_storage_pool_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_storage_pool_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all storage pools for a node
    # Lists all storage pools of a node
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :nodes Filter only for the specified nodes, if not specified no filtering.
    # @option opts [Array<String>] :storage_pools Filter only for the specified storage pools, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<StoragePool>]
    def node_storage_pool_list(node, opts = {})
      data, _status_code, _headers = node_storage_pool_list_with_http_info(node, opts)
      data
    end

    # lists all storage pools for a node
    # Lists all storage pools of a node
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :nodes Filter only for the specified nodes, if not specified no filtering.
    # @option opts [Array<String>] :storage_pools Filter only for the specified storage pools, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<StoragePool>, Integer, Hash)>] Array<StoragePool> data, response status code and response headers
    def node_storage_pool_list_with_http_info(node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_storage_pool_list ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_storage_pool_list"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.node_storage_pool_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.node_storage_pool_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.node_storage_pool_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/nodes/{node}/storage-pools'.sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'nodes'] = @api_client.build_collection_param(opts[:'nodes'], :multi) if !opts[:'nodes'].nil?
      query_params[:'storage_pools'] = @api_client.build_collection_param(opts[:'storage_pools'], :multi) if !opts[:'storage_pools'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<StoragePool>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_storage_pool_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_storage_pool_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a storage pool
    # Sets or modifies properties  Possible properties are: - `StorDriver/LvmVg` - regex[`[a-zA-Z0-9_-]+`] - `StorDriver/ThinPool` - regex[`[a-zA-Z0-9_-]+`] - `StorDriver/ZPool` - regex[`[a-zA-Z0-9_/-]+`] - `StorDriver/ZPoolThin` - regex[`[a-zA-Z0-9_/-]+`] - `StorDriver/FileDir` - regex[`.*`] - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Preferred network interface to use  - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Preferred network interface to use  - `StorDriver/LvcreateType` - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - `StorDriver/WaitTimeoutAfterCreate` - regex[`[0-9]+`] - `sys/fs/blkio_throttle_read` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - `sys/fs/blkio_throttle_write` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  
    # @param node [String] node to use
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePoolDefinitionModify] :storage_pool_definition_modify 
    # @return [ApiCallRc]
    def node_storage_pool_modify(node, storagepool, opts = {})
      data, _status_code, _headers = node_storage_pool_modify_with_http_info(node, storagepool, opts)
      data
    end

    # modify a storage pool
    # Sets or modifies properties  Possible properties are: - &#x60;StorDriver/LvmVg&#x60; - regex[&#x60;[a-zA-Z0-9_-]+&#x60;] - &#x60;StorDriver/ThinPool&#x60; - regex[&#x60;[a-zA-Z0-9_-]+&#x60;] - &#x60;StorDriver/ZPool&#x60; - regex[&#x60;[a-zA-Z0-9_/-]+&#x60;] - &#x60;StorDriver/ZPoolThin&#x60; - regex[&#x60;[a-zA-Z0-9_/-]+&#x60;] - &#x60;StorDriver/FileDir&#x60; - regex[&#x60;.*&#x60;] - &#x60;PrefNic&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Preferred network interface to use  - &#x60;NVMe/PrefNic&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Preferred network interface to use  - &#x60;StorDriver/LvcreateType&#x60; - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - &#x60;StorDriver/WaitTimeoutAfterCreate&#x60; - regex[&#x60;[0-9]+&#x60;] - &#x60;sys/fs/blkio_throttle_read&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - &#x60;sys/fs/blkio_throttle_write&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  
    # @param node [String] node to use
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePoolDefinitionModify] :storage_pool_definition_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def node_storage_pool_modify_with_http_info(node, storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.node_storage_pool_modify ...'
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.node_storage_pool_modify"
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.node_storage_pool_modify"
      end
      # resource path
      local_var_path = '/v1/nodes/{node}/storage-pools/{storagepool}'.sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'storage_pool_definition_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.node_storage_pool_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#node_storage_pool_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # query the maximum volume size
    # Query the maximum possible volume size storage pools
    # @param [Hash] opts the optional parameters
    # @option opts [AutoSelectFilter] :auto_select_filter 
    # @return [MaxVolumeSizes]
    def query_max_volume_size(opts = {})
      data, _status_code, _headers = query_max_volume_size_with_http_info(opts)
      data
    end

    # query the maximum volume size
    # Query the maximum possible volume size storage pools
    # @param [Hash] opts the optional parameters
    # @option opts [AutoSelectFilter] :auto_select_filter 
    # @return [Array<(MaxVolumeSizes, Integer, Hash)>] MaxVolumeSizes data, response status code and response headers
    def query_max_volume_size_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.query_max_volume_size ...'
      end
      # resource path
      local_var_path = '/v1/query-max-volume-size'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'auto_select_filter'])

      # return_type
      return_type = opts[:debug_return_type] || 'MaxVolumeSizes'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.query_max_volume_size",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:OPTIONS, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#query_max_volume_size\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # query the maximum volume size from a given resource group
    # Query the maximum possible volume size storage pools
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @return [MaxVolumeSizes]
    def query_max_volume_size_from_rsc_grp(resource_group, opts = {})
      data, _status_code, _headers = query_max_volume_size_from_rsc_grp_with_http_info(resource_group, opts)
      data
    end

    # query the maximum volume size from a given resource group
    # Query the maximum possible volume size storage pools
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(MaxVolumeSizes, Integer, Hash)>] MaxVolumeSizes data, response status code and response headers
    def query_max_volume_size_from_rsc_grp_with_http_info(resource_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.query_max_volume_size_from_rsc_grp ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.query_max_volume_size_from_rsc_grp"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}/query-max-volume-size'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'MaxVolumeSizes'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.query_max_volume_size_from_rsc_grp",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#query_max_volume_size_from_rsc_grp\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # autoplace resource
    # Auto place the resource on the specified place_count redundency. If place_count isn't given 2 is the default. 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [AutoPlaceRequest] :auto_place_request 
    # @return [ApiCallRc]
    def resource_autoplace(resource, opts = {})
      data, _status_code, _headers = resource_autoplace_with_http_info(resource, opts)
      data
    end

    # autoplace resource
    # Auto place the resource on the specified place_count redundency. If place_count isn&#39;t given 2 is the default. 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [AutoPlaceRequest] :auto_place_request 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_autoplace_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_autoplace ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_autoplace"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/autoplace'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'auto_place_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_autoplace",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_autoplace\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # show the specified resource connection
    # show the specified resource connection
    # @param resource [String] resource to use
    # @param node_a [String] source node of the connection
    # @param node_b [String] target node of the connection
    # @param [Hash] opts the optional parameters
    # @return [Array<ResourceConnection>]
    def resource_connection_list(resource, node_a, node_b, opts = {})
      data, _status_code, _headers = resource_connection_list_with_http_info(resource, node_a, node_b, opts)
      data
    end

    # show the specified resource connection
    # show the specified resource connection
    # @param resource [String] resource to use
    # @param node_a [String] source node of the connection
    # @param node_b [String] target node of the connection
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<ResourceConnection>, Integer, Hash)>] Array<ResourceConnection> data, response status code and response headers
    def resource_connection_list_with_http_info(resource, node_a, node_b, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_connection_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_connection_list"
      end
      # verify the required parameter 'node_a' is set
      if @api_client.config.client_side_validation && node_a.nil?
        fail ArgumentError, "Missing the required parameter 'node_a' when calling DevelopersApi.resource_connection_list"
      end
      # verify the required parameter 'node_b' is set
      if @api_client.config.client_side_validation && node_b.nil?
        fail ArgumentError, "Missing the required parameter 'node_b' when calling DevelopersApi.resource_connection_list"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resource-connections/{node_a}/{node_b}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node_a' + '}', CGI.escape(node_a.to_s)).sub('{' + 'node_b' + '}', CGI.escape(node_b.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ResourceConnection>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_connection_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_connection_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a resource connection
    # Sets or modifies properties  Possible properties are: - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`] - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`] - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`] - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`] - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`] - `DrbdOptions/PeerDevice/bitmap` - boolean - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`] - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`] - `DrbdOptions/Net/protocol` - enum     * A     * B     * C  - `DrbdOptions/Net/allow-two-primaries` - boolean - `DrbdOptions/Net/after-sb-0pri` - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - `DrbdOptions/Net/ko-count` - range[`0-200`] - `DrbdOptions/Net/data-integrity-alg` - string - `DrbdOptions/Net/ping-timeout` - range[`1-300`] - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/transport` - string - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/max-buffers` - range[`32-131072`] - `DrbdOptions/Net/fencing` - enum     * dont-care     * resource-only     * resource-and-stonith  - `DrbdOptions/Net/csums-alg` - string - `DrbdOptions/Net/always-asbp` - boolean - `DrbdOptions/Net/congestion-extents` - range[`67-65534`] - `DrbdOptions/Net/on-congestion` - enum     * block     * pull-ahead     * disconnect  - `DrbdOptions/Net/ping-int` - range[`1-120`] - `DrbdOptions/Net/rr-conflict` - enum     * disconnect     * call-pri-lost     * violently  - `DrbdOptions/Net/tcp-cork` - boolean - `DrbdOptions/Net/use-rle` - boolean - `DrbdOptions/Net/csums-after-crash-only` - boolean - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`] - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`] - `DrbdOptions/Net/cram-hmac-alg` - string - `DrbdOptions/Net/verify-alg` - string - `DrbdOptions/Net/shared-secret` - string - `DrbdOptions/Net/connect-int` - range[`1-120`] - `DrbdOptions/Net/timeout` - range[`1-600`] - `DrbdOptions/Net/after-sb-2pri` - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Net/after-sb-1pri` - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  
    # @param resource [String] resource to use
    # @param node_a [String] source node of the connection
    # @param node_b [String] target node of the connection
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceConnectionModify] :resource_connection_modify 
    # @return [ApiCallRc]
    def resource_connection_modify(resource, node_a, node_b, opts = {})
      data, _status_code, _headers = resource_connection_modify_with_http_info(resource, node_a, node_b, opts)
      data
    end

    # modify a resource connection
    # Sets or modifies properties  Possible properties are: - &#x60;DrbdOptions/PeerDevice/c-fill-target&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/PeerDevice/c-max-rate&#x60; - range[&#x60;250-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/resync-rate&#x60; - range[&#x60;1-8388608&#x60;] - &#x60;DrbdOptions/PeerDevice/c-delay-target&#x60; - range[&#x60;1-100&#x60;] - &#x60;DrbdOptions/PeerDevice/c-min-rate&#x60; - range[&#x60;0-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/bitmap&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-plan-ahead&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Net/max-epoch-size&#x60; - range[&#x60;1-20000&#x60;] - &#x60;DrbdOptions/Net/protocol&#x60; - enum     * A     * B     * C  - &#x60;DrbdOptions/Net/allow-two-primaries&#x60; - boolean - &#x60;DrbdOptions/Net/after-sb-0pri&#x60; - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - &#x60;DrbdOptions/Net/ko-count&#x60; - range[&#x60;0-200&#x60;] - &#x60;DrbdOptions/Net/data-integrity-alg&#x60; - string - &#x60;DrbdOptions/Net/ping-timeout&#x60; - range[&#x60;1-300&#x60;] - &#x60;DrbdOptions/Net/sndbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/transport&#x60; - string - &#x60;DrbdOptions/Net/rcvbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/max-buffers&#x60; - range[&#x60;32-131072&#x60;] - &#x60;DrbdOptions/Net/fencing&#x60; - enum     * dont-care     * resource-only     * resource-and-stonith  - &#x60;DrbdOptions/Net/csums-alg&#x60; - string - &#x60;DrbdOptions/Net/always-asbp&#x60; - boolean - &#x60;DrbdOptions/Net/congestion-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Net/on-congestion&#x60; - enum     * block     * pull-ahead     * disconnect  - &#x60;DrbdOptions/Net/ping-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/rr-conflict&#x60; - enum     * disconnect     * call-pri-lost     * violently  - &#x60;DrbdOptions/Net/tcp-cork&#x60; - boolean - &#x60;DrbdOptions/Net/use-rle&#x60; - boolean - &#x60;DrbdOptions/Net/csums-after-crash-only&#x60; - boolean - &#x60;DrbdOptions/Net/socket-check-timeout&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Net/congestion-fill&#x60; - range[&#x60;0-20971520&#x60;] - &#x60;DrbdOptions/Net/cram-hmac-alg&#x60; - string - &#x60;DrbdOptions/Net/verify-alg&#x60; - string - &#x60;DrbdOptions/Net/shared-secret&#x60; - string - &#x60;DrbdOptions/Net/connect-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/timeout&#x60; - range[&#x60;1-600&#x60;] - &#x60;DrbdOptions/Net/after-sb-2pri&#x60; - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Net/after-sb-1pri&#x60; - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  
    # @param resource [String] resource to use
    # @param node_a [String] source node of the connection
    # @param node_b [String] target node of the connection
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceConnectionModify] :resource_connection_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_connection_modify_with_http_info(resource, node_a, node_b, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_connection_modify ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_connection_modify"
      end
      # verify the required parameter 'node_a' is set
      if @api_client.config.client_side_validation && node_a.nil?
        fail ArgumentError, "Missing the required parameter 'node_a' when calling DevelopersApi.resource_connection_modify"
      end
      # verify the required parameter 'node_b' is set
      if @api_client.config.client_side_validation && node_b.nil?
        fail ArgumentError, "Missing the required parameter 'node_b' when calling DevelopersApi.resource_connection_modify"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resource-connections/{node_a}/{node_b}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node_a' + '}', CGI.escape(node_a.to_s)).sub('{' + 'node_b' + '}', CGI.escape(node_b.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_connection_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_connection_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_connection_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # list all resource connections for resource
    # List all resource connections for resource
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @return [Array<ResourceConnection>]
    def resource_connections_list(resource, opts = {})
      data, _status_code, _headers = resource_connections_list_with_http_info(resource, opts)
      data
    end

    # list all resource connections for resource
    # List all resource connections for resource
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<ResourceConnection>, Integer, Hash)>] Array<ResourceConnection> data, response status code and response headers
    def resource_connections_list_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_connections_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_connections_list"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resource-connections'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ResourceConnection>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_connections_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_connections_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # create one or more resources.
    # Adds one or more resource(s). 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Array<ResourceCreate>] :resource_create 
    # @return [ApiCallRc]
    def resource_create(resource, opts = {})
      data, _status_code, _headers = resource_create_with_http_info(resource, opts)
      data
    end

    # create one or more resources.
    # Adds one or more resource(s). 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Array<ResourceCreate>] :resource_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_create_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_create ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_create"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # create a resource on a node
    # Adds a resource on a node.  To use a specific storage pool add the `StorPoolName` property and use the storage pool name as value. If the `StorPoolName` property is not set, the `DfltStorPool` will be used.  To create a diskless resource you have to set the \"DISKLESS\" flag in the flags list. ``` {   \"resource\": {     \"flags\": [\"DISKLESS\"]   } } ``` 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceCreate] :resource_create 
    # @return [ApiCallRc]
    def resource_create_on_node(resource, node, opts = {})
      data, _status_code, _headers = resource_create_on_node_with_http_info(resource, node, opts)
      data
    end

    # create a resource on a node
    # Adds a resource on a node.  To use a specific storage pool add the &#x60;StorPoolName&#x60; property and use the storage pool name as value. If the &#x60;StorPoolName&#x60; property is not set, the &#x60;DfltStorPool&#x60; will be used.  To create a diskless resource you have to set the \&quot;DISKLESS\&quot; flag in the flags list. &#x60;&#x60;&#x60; {   \&quot;resource\&quot;: {     \&quot;flags\&quot;: [\&quot;DISKLESS\&quot;]   } } &#x60;&#x60;&#x60; 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceCreate] :resource_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_create_on_node_with_http_info(resource, node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_create_on_node ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_create_on_node"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_create_on_node"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_create_on_node",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_create_on_node\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # add a resource-definition
    # Adds a resource-definition.  Only required property is the name of the resource definition. All other properties are optional. 
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceDefinitionCreate] :resource_definition_create 
    # @return [ApiCallRc]
    def resource_definition_create(opts = {})
      data, _status_code, _headers = resource_definition_create_with_http_info(opts)
      data
    end

    # add a resource-definition
    # Adds a resource-definition.  Only required property is the name of the resource definition. All other properties are optional. 
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceDefinitionCreate] :resource_definition_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_definition_create_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_definition_create ...'
      end
      # resource path
      local_var_path = '/v1/resource-definitions'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_definition_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_definition_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_definition_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a resource-definition
    # Delete a resource-definition
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_definition_delete(resource, opts = {})
      data, _status_code, _headers = resource_definition_delete_with_http_info(resource, opts)
      data
    end

    # delete a resource-definition
    # Delete a resource-definition
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_definition_delete_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_definition_delete ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_definition_delete"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_definition_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_definition_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all resource-definitions
    # Lists all resource definitions.  A single resource definition can be queried by adding its name to the resource string like:  /v1/resource-definitions/rsc1 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :resource_definitions Filter only for the specified resource definitions, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<ResourceDefinition>]
    def resource_definition_list(opts = {})
      data, _status_code, _headers = resource_definition_list_with_http_info(opts)
      data
    end

    # lists all resource-definitions
    # Lists all resource definitions.  A single resource definition can be queried by adding its name to the resource string like:  /v1/resource-definitions/rsc1 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :resource_definitions Filter only for the specified resource definitions, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<ResourceDefinition>, Integer, Hash)>] Array<ResourceDefinition> data, response status code and response headers
    def resource_definition_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_definition_list ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.resource_definition_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_definition_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_definition_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/resource-definitions'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'resource_definitions'] = @api_client.build_collection_param(opts[:'resource_definitions'], :multi) if !opts[:'resource_definitions'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ResourceDefinition>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_definition_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_definition_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a resource-definition
    # Sets or modifies properties  Possible properties are: - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `DrbdMetaType` - enum     * external     * internal  - `PeerSlotsNewResource` - range[`1-31`]      DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future  - `DrbdProxy/CompressionType` - enum     * zlib     * lzma     * lz4     * zstd  - `FileSystem/Type` - enum      File system type to use      * ext4     * xfs  - `FileSystem/MkfsParams` - string      Additional parameters for the mkfs command  - `NVMe/enabled` - enum     * rdma     * tcp  - `NVMe/enabled` - range[`1-65535`] - `StorDriver/LvcreateType` - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - `sys/fs/blkio_throttle_read` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - `sys/fs/blkio_throttle_write` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - `DrbdOptions/auto-quorum` - enum      Enables automatic setting of the 'quroum' and 'on-no-quroum' property      * io-error     * suspend-io     * disabled  - `DrbdOptions/auto-add-quorum-tiebreaker` - boolean_true_false      Enables automatic management (creation and deletion) of tie breaking resource  - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name for writecache  - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]      Size of the writecache in % (0-100) or KiB otherwise  - `Writecache/Blocksize` - long      4096 is recommended; the maximum block size is the page size  - `Writecache/Options/StartSector` - long      offset from the start of cache device in 512-byte sectors  - `Writecache/Options/HighWatermark` - long      start writeback when the number of used blocks reach this watermark  - `Writecache/Options/LowWatermark` - long      stop writeback when the number of used blocks drops below this watermark  - `Writecache/Options/WritebackJobs` - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - `Writecache/Options/AutocommitBlocks` - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - `Writecache/Options/AutocommitTime` - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - `Writecache/Options/Fua` - enum      \"On\" results in \"fua\" as argument, whereas the value \"Off\" results in \"nofua\" argument      * On     * Off  - `Writecache/Options/Additional` - string      Additional arguments passed through  - `DrbdOptions/Disk/read-balancing` - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - `DrbdOptions/Disk/on-io-error` - enum     * pass_on     * call-local-io-error     * detach  - `DrbdOptions/Disk/disk-drain` - boolean - `DrbdOptions/Disk/resync-after` - string - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`] - `DrbdOptions/Disk/disable-write-same` - boolean - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`] - `DrbdOptions/Disk/disk-flushes` - boolean - `DrbdOptions/Disk/al-extents` - range[`67-65534`] - `DrbdOptions/Disk/al-updates` - boolean - `DrbdOptions/Disk/md-flushes` - boolean - `DrbdOptions/Disk/disk-barrier` - boolean - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`] - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`] - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`] - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`] - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`] - `DrbdOptions/PeerDevice/bitmap` - boolean - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`] - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`] - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]     * off     * majority     * all  - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`] - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`] - `DrbdOptions/Resource/quorum` - enum [`1-32`]     * off     * majority     * all  - `DrbdOptions/Resource/on-no-data-accessible` - enum     * io-error     * suspend-io  - `DrbdOptions/Resource/auto-promote` - boolean - `DrbdOptions/Resource/cpu-mask` - string - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`] - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`] - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`] - `DrbdOptions/Resource/on-no-quorum` - enum     * io-error     * suspend-io  - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`] - `DrbdOptions/Net/protocol` - enum     * A     * B     * C  - `DrbdOptions/Net/allow-two-primaries` - boolean - `DrbdOptions/Net/after-sb-0pri` - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - `DrbdOptions/Net/ko-count` - range[`0-200`] - `DrbdOptions/Net/data-integrity-alg` - string - `DrbdOptions/Net/ping-timeout` - range[`1-300`] - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/transport` - string - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/max-buffers` - range[`32-131072`] - `DrbdOptions/Net/fencing` - enum     * dont-care     * resource-only     * resource-and-stonith  - `DrbdOptions/Net/csums-alg` - string - `DrbdOptions/Net/always-asbp` - boolean - `DrbdOptions/Net/congestion-extents` - range[`67-65534`] - `DrbdOptions/Net/on-congestion` - enum     * block     * pull-ahead     * disconnect  - `DrbdOptions/Net/ping-int` - range[`1-120`] - `DrbdOptions/Net/rr-conflict` - enum     * disconnect     * call-pri-lost     * violently  - `DrbdOptions/Net/tcp-cork` - boolean - `DrbdOptions/Net/use-rle` - boolean - `DrbdOptions/Net/csums-after-crash-only` - boolean - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`] - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`] - `DrbdOptions/Net/cram-hmac-alg` - string - `DrbdOptions/Net/verify-alg` - string - `DrbdOptions/Net/shared-secret` - string - `DrbdOptions/Net/connect-int` - range[`1-120`] - `DrbdOptions/Net/timeout` - range[`1-600`] - `DrbdOptions/Net/after-sb-2pri` - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Net/after-sb-1pri` - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Handlers/after-resync-target` - string - `DrbdOptions/Handlers/before-resync-target` - string - `DrbdOptions/Handlers/before-resync-source` - string - `DrbdOptions/Handlers/out-of-sync` - string - `DrbdOptions/Handlers/quorum-lost` - string - `DrbdOptions/Handlers/fence-peer` - string - `DrbdOptions/Handlers/unfence-peer` - string - `DrbdOptions/Handlers/initial-split-brain` - string - `DrbdOptions/Handlers/local-io-error` - string - `DrbdOptions/Handlers/pri-lost` - string - `DrbdOptions/Handlers/pri-lost-after-sb` - string - `DrbdOptions/Handlers/pri-on-incon-degr` - string - `DrbdOptions/Handlers/split-brain` - string 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceDefinitionModify] :resource_definition_modify 
    # @return [ApiCallRc]
    def resource_definition_modify(resource, opts = {})
      data, _status_code, _headers = resource_definition_modify_with_http_info(resource, opts)
      data
    end

    # modify a resource-definition
    # Sets or modifies properties  Possible properties are: - &#x60;StorPoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;StorPoolNameDrbdMeta&#x60; - regex[&#x60;^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;DrbdMetaType&#x60; - enum     * external     * internal  - &#x60;PeerSlotsNewResource&#x60; - range[&#x60;1-31&#x60;]      DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future  - &#x60;DrbdProxy/CompressionType&#x60; - enum     * zlib     * lzma     * lz4     * zstd  - &#x60;FileSystem/Type&#x60; - enum      File system type to use      * ext4     * xfs  - &#x60;FileSystem/MkfsParams&#x60; - string      Additional parameters for the mkfs command  - &#x60;NVMe/enabled&#x60; - enum     * rdma     * tcp  - &#x60;NVMe/enabled&#x60; - range[&#x60;1-65535&#x60;] - &#x60;StorDriver/LvcreateType&#x60; - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - &#x60;sys/fs/blkio_throttle_read&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - &#x60;sys/fs/blkio_throttle_write&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - &#x60;DrbdOptions/auto-quorum&#x60; - enum      Enables automatic setting of the &#39;quroum&#39; and &#39;on-no-quroum&#39; property      * io-error     * suspend-io     * disabled  - &#x60;DrbdOptions/auto-add-quorum-tiebreaker&#x60; - boolean_true_false      Enables automatic management (creation and deletion) of tie breaking resource  - &#x60;Writecache/PoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name for writecache  - &#x60;Writecache/Size&#x60; - regex[&#x60;^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$&#x60;]      Size of the writecache in % (0-100) or KiB otherwise  - &#x60;Writecache/Blocksize&#x60; - long      4096 is recommended; the maximum block size is the page size  - &#x60;Writecache/Options/StartSector&#x60; - long      offset from the start of cache device in 512-byte sectors  - &#x60;Writecache/Options/HighWatermark&#x60; - long      start writeback when the number of used blocks reach this watermark  - &#x60;Writecache/Options/LowWatermark&#x60; - long      stop writeback when the number of used blocks drops below this watermark  - &#x60;Writecache/Options/WritebackJobs&#x60; - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - &#x60;Writecache/Options/AutocommitBlocks&#x60; - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - &#x60;Writecache/Options/AutocommitTime&#x60; - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - &#x60;Writecache/Options/Fua&#x60; - enum      \&quot;On\&quot; results in \&quot;fua\&quot; as argument, whereas the value \&quot;Off\&quot; results in \&quot;nofua\&quot; argument      * On     * Off  - &#x60;Writecache/Options/Additional&#x60; - string      Additional arguments passed through  - &#x60;DrbdOptions/Disk/read-balancing&#x60; - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - &#x60;DrbdOptions/Disk/on-io-error&#x60; - enum     * pass_on     * call-local-io-error     * detach  - &#x60;DrbdOptions/Disk/disk-drain&#x60; - boolean - &#x60;DrbdOptions/Disk/resync-after&#x60; - string - &#x60;DrbdOptions/Disk/disk-timeout&#x60; - range[&#x60;0-6000&#x60;] - &#x60;DrbdOptions/Disk/disable-write-same&#x60; - boolean - &#x60;DrbdOptions/Disk/rs-discard-granularity&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/Disk/disk-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/al-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Disk/al-updates&#x60; - boolean - &#x60;DrbdOptions/Disk/md-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/disk-barrier&#x60; - boolean - &#x60;DrbdOptions/Disk/discard-zeroes-if-aligned&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-fill-target&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/PeerDevice/c-max-rate&#x60; - range[&#x60;250-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/resync-rate&#x60; - range[&#x60;1-8388608&#x60;] - &#x60;DrbdOptions/PeerDevice/c-delay-target&#x60; - range[&#x60;1-100&#x60;] - &#x60;DrbdOptions/PeerDevice/c-min-rate&#x60; - range[&#x60;0-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/bitmap&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-plan-ahead&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Resource/peer-ack-delay&#x60; - range[&#x60;1-10000&#x60;] - &#x60;DrbdOptions/Resource/quorum-minimum-redundancy&#x60; - enum [&#x60;1-32&#x60;]     * off     * majority     * all  - &#x60;DrbdOptions/Resource/max-io-depth&#x60; - range[&#x60;4-4294967295&#x60;] - &#x60;DrbdOptions/Resource/auto-promote-timeout&#x60; - range[&#x60;0-600&#x60;] - &#x60;DrbdOptions/Resource/quorum&#x60; - enum [&#x60;1-32&#x60;]     * off     * majority     * all  - &#x60;DrbdOptions/Resource/on-no-data-accessible&#x60; - enum     * io-error     * suspend-io  - &#x60;DrbdOptions/Resource/auto-promote&#x60; - boolean - &#x60;DrbdOptions/Resource/cpu-mask&#x60; - string - &#x60;DrbdOptions/Resource/twopc-timeout&#x60; - range[&#x60;50-600&#x60;] - &#x60;DrbdOptions/Resource/twopc-retry-timeout&#x60; - range[&#x60;1-50&#x60;] - &#x60;DrbdOptions/Resource/peer-ack-window&#x60; - range[&#x60;2048-204800&#x60;] - &#x60;DrbdOptions/Resource/on-no-quorum&#x60; - enum     * io-error     * suspend-io  - &#x60;DrbdOptions/Net/max-epoch-size&#x60; - range[&#x60;1-20000&#x60;] - &#x60;DrbdOptions/Net/protocol&#x60; - enum     * A     * B     * C  - &#x60;DrbdOptions/Net/allow-two-primaries&#x60; - boolean - &#x60;DrbdOptions/Net/after-sb-0pri&#x60; - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - &#x60;DrbdOptions/Net/ko-count&#x60; - range[&#x60;0-200&#x60;] - &#x60;DrbdOptions/Net/data-integrity-alg&#x60; - string - &#x60;DrbdOptions/Net/ping-timeout&#x60; - range[&#x60;1-300&#x60;] - &#x60;DrbdOptions/Net/sndbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/transport&#x60; - string - &#x60;DrbdOptions/Net/rcvbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/max-buffers&#x60; - range[&#x60;32-131072&#x60;] - &#x60;DrbdOptions/Net/fencing&#x60; - enum     * dont-care     * resource-only     * resource-and-stonith  - &#x60;DrbdOptions/Net/csums-alg&#x60; - string - &#x60;DrbdOptions/Net/always-asbp&#x60; - boolean - &#x60;DrbdOptions/Net/congestion-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Net/on-congestion&#x60; - enum     * block     * pull-ahead     * disconnect  - &#x60;DrbdOptions/Net/ping-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/rr-conflict&#x60; - enum     * disconnect     * call-pri-lost     * violently  - &#x60;DrbdOptions/Net/tcp-cork&#x60; - boolean - &#x60;DrbdOptions/Net/use-rle&#x60; - boolean - &#x60;DrbdOptions/Net/csums-after-crash-only&#x60; - boolean - &#x60;DrbdOptions/Net/socket-check-timeout&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Net/congestion-fill&#x60; - range[&#x60;0-20971520&#x60;] - &#x60;DrbdOptions/Net/cram-hmac-alg&#x60; - string - &#x60;DrbdOptions/Net/verify-alg&#x60; - string - &#x60;DrbdOptions/Net/shared-secret&#x60; - string - &#x60;DrbdOptions/Net/connect-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/timeout&#x60; - range[&#x60;1-600&#x60;] - &#x60;DrbdOptions/Net/after-sb-2pri&#x60; - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Net/after-sb-1pri&#x60; - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Handlers/after-resync-target&#x60; - string - &#x60;DrbdOptions/Handlers/before-resync-target&#x60; - string - &#x60;DrbdOptions/Handlers/before-resync-source&#x60; - string - &#x60;DrbdOptions/Handlers/out-of-sync&#x60; - string - &#x60;DrbdOptions/Handlers/quorum-lost&#x60; - string - &#x60;DrbdOptions/Handlers/fence-peer&#x60; - string - &#x60;DrbdOptions/Handlers/unfence-peer&#x60; - string - &#x60;DrbdOptions/Handlers/initial-split-brain&#x60; - string - &#x60;DrbdOptions/Handlers/local-io-error&#x60; - string - &#x60;DrbdOptions/Handlers/pri-lost&#x60; - string - &#x60;DrbdOptions/Handlers/pri-lost-after-sb&#x60; - string - &#x60;DrbdOptions/Handlers/pri-on-incon-degr&#x60; - string - &#x60;DrbdOptions/Handlers/split-brain&#x60; - string 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceDefinitionModify] :resource_definition_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_definition_modify_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_definition_modify ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_definition_modify"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_definition_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_definition_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_definition_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a resource
    # Delete a resource on a node
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_delete(resource, node, opts = {})
      data, _status_code, _headers = resource_delete_with_http_info(resource, node, opts)
      data
    end

    # delete a resource
    # Delete a resource on a node
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_delete_with_http_info(resource, node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_delete ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_delete"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_delete"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # disables a drbd proxy on a node connection
    # Disables a drbd proxy on a node connection
    # @param resource [String] resource to use
    # @param node_a [String] 
    # @param node_b [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_drbd_proxy_disable(resource, node_a, node_b, opts = {})
      data, _status_code, _headers = resource_drbd_proxy_disable_with_http_info(resource, node_a, node_b, opts)
      data
    end

    # disables a drbd proxy on a node connection
    # Disables a drbd proxy on a node connection
    # @param resource [String] resource to use
    # @param node_a [String] 
    # @param node_b [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_drbd_proxy_disable_with_http_info(resource, node_a, node_b, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_drbd_proxy_disable ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_drbd_proxy_disable"
      end
      # verify the required parameter 'node_a' is set
      if @api_client.config.client_side_validation && node_a.nil?
        fail ArgumentError, "Missing the required parameter 'node_a' when calling DevelopersApi.resource_drbd_proxy_disable"
      end
      # verify the required parameter 'node_b' is set
      if @api_client.config.client_side_validation && node_b.nil?
        fail ArgumentError, "Missing the required parameter 'node_b' when calling DevelopersApi.resource_drbd_proxy_disable"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/drbd-proxy/disable/{nodeA}/{nodeB}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'nodeA' + '}', CGI.escape(node_a.to_s)).sub('{' + 'nodeB' + '}', CGI.escape(node_b.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_drbd_proxy_disable",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_drbd_proxy_disable\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # enable a drbd proxy on a node connection
    # Enables a drbd proxy on a node connection
    # @param resource [String] resource to use
    # @param node_a [String] source node of the connection
    # @param node_b [String] target node of the connection
    # @param [Hash] opts the optional parameters
    # @option opts [DrbdProxyEnable] :drbd_proxy_enable 
    # @return [ApiCallRc]
    def resource_drbd_proxy_enable(resource, node_a, node_b, opts = {})
      data, _status_code, _headers = resource_drbd_proxy_enable_with_http_info(resource, node_a, node_b, opts)
      data
    end

    # enable a drbd proxy on a node connection
    # Enables a drbd proxy on a node connection
    # @param resource [String] resource to use
    # @param node_a [String] source node of the connection
    # @param node_b [String] target node of the connection
    # @param [Hash] opts the optional parameters
    # @option opts [DrbdProxyEnable] :drbd_proxy_enable 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_drbd_proxy_enable_with_http_info(resource, node_a, node_b, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_drbd_proxy_enable ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_drbd_proxy_enable"
      end
      # verify the required parameter 'node_a' is set
      if @api_client.config.client_side_validation && node_a.nil?
        fail ArgumentError, "Missing the required parameter 'node_a' when calling DevelopersApi.resource_drbd_proxy_enable"
      end
      # verify the required parameter 'node_b' is set
      if @api_client.config.client_side_validation && node_b.nil?
        fail ArgumentError, "Missing the required parameter 'node_b' when calling DevelopersApi.resource_drbd_proxy_enable"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/drbd-proxy/enable/{node_a}/{node_b}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node_a' + '}', CGI.escape(node_a.to_s)).sub('{' + 'node_b' + '}', CGI.escape(node_b.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'drbd_proxy_enable'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_drbd_proxy_enable",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_drbd_proxy_enable\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify drbd proxy option properties
    # Sets or modifies properties  Possible properties are: - `DrbdOptions/Proxy/memlimit` - range[`16777216-9223372036854775807`] - `DrbdOptions/Proxy/read-loops` - range[`0-2147483647`] - `DrbdOptions/Proxy/sndbuf-size` - range[`0-10485760`] - `DrbdOptions/Proxy/rcvbuf-size` - range[`0-10485760`] - `DrbdOptions/Proxy/ping-timeout` - range[`1-300`] - `DrbdOptions/ProxyCompression/dict-size` - range[`4096-1610612736`] - `DrbdOptions/ProxyCompression/lc` - range[`0-4`] - `DrbdOptions/ProxyCompression/lp` - range[`0-4`] - `DrbdOptions/ProxyCompression/pb` - range[`0-4`] - `DrbdOptions/ProxyCompression/nice-len` - range[`0-273`] - `DrbdOptions/ProxyCompression/mf` - enum     * hc4     * hc3     * bt2     * bt3     * bt4  - `DrbdOptions/ProxyCompression/mode` - enum     * fast     * normal  - `DrbdOptions/ProxyCompression/depth` - range[`0-1000`] - `DrbdOptions/ProxyCompression/level` - range[`1-9`] - `DrbdOptions/ProxyCompression/contexts` - range[`1-253`] - `DrbdOptions/ProxyCompression/fallback-to-zlib` - enum     * off     * on  - `DrbdOptions/ProxyCompression/numa-threshold` - range[`0-253`] - `DrbdOptions/ProxyCompression/level` - range[`1-9`] - `DrbdOptions/ProxyCompression/level` - range[`1-22`] 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [DrbdProxyModify] :drbd_proxy_modify 
    # @return [ApiCallRc]
    def resource_drbd_proxy_modify(resource, opts = {})
      data, _status_code, _headers = resource_drbd_proxy_modify_with_http_info(resource, opts)
      data
    end

    # modify drbd proxy option properties
    # Sets or modifies properties  Possible properties are: - &#x60;DrbdOptions/Proxy/memlimit&#x60; - range[&#x60;16777216-9223372036854775807&#x60;] - &#x60;DrbdOptions/Proxy/read-loops&#x60; - range[&#x60;0-2147483647&#x60;] - &#x60;DrbdOptions/Proxy/sndbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Proxy/rcvbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Proxy/ping-timeout&#x60; - range[&#x60;1-300&#x60;] - &#x60;DrbdOptions/ProxyCompression/dict-size&#x60; - range[&#x60;4096-1610612736&#x60;] - &#x60;DrbdOptions/ProxyCompression/lc&#x60; - range[&#x60;0-4&#x60;] - &#x60;DrbdOptions/ProxyCompression/lp&#x60; - range[&#x60;0-4&#x60;] - &#x60;DrbdOptions/ProxyCompression/pb&#x60; - range[&#x60;0-4&#x60;] - &#x60;DrbdOptions/ProxyCompression/nice-len&#x60; - range[&#x60;0-273&#x60;] - &#x60;DrbdOptions/ProxyCompression/mf&#x60; - enum     * hc4     * hc3     * bt2     * bt3     * bt4  - &#x60;DrbdOptions/ProxyCompression/mode&#x60; - enum     * fast     * normal  - &#x60;DrbdOptions/ProxyCompression/depth&#x60; - range[&#x60;0-1000&#x60;] - &#x60;DrbdOptions/ProxyCompression/level&#x60; - range[&#x60;1-9&#x60;] - &#x60;DrbdOptions/ProxyCompression/contexts&#x60; - range[&#x60;1-253&#x60;] - &#x60;DrbdOptions/ProxyCompression/fallback-to-zlib&#x60; - enum     * off     * on  - &#x60;DrbdOptions/ProxyCompression/numa-threshold&#x60; - range[&#x60;0-253&#x60;] - &#x60;DrbdOptions/ProxyCompression/level&#x60; - range[&#x60;1-9&#x60;] - &#x60;DrbdOptions/ProxyCompression/level&#x60; - range[&#x60;1-22&#x60;] 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [DrbdProxyModify] :drbd_proxy_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_drbd_proxy_modify_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_drbd_proxy_modify ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_drbd_proxy_modify"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/drbd-proxy'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'drbd_proxy_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_drbd_proxy_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_drbd_proxy_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # add a resource-group
    # Adds a resource-group.  Only required property is the name of the resource group. All other properties are optional. 
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceGroup] :resource_group 
    # @return [ApiCallRc]
    def resource_group_create(opts = {})
      data, _status_code, _headers = resource_group_create_with_http_info(opts)
      data
    end

    # add a resource-group
    # Adds a resource-group.  Only required property is the name of the resource group. All other properties are optional. 
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceGroup] :resource_group 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_group_create_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_group_create ...'
      end
      # resource path
      local_var_path = '/v1/resource-groups'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_group'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_group_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_group_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a resource-group
    # Delete a resource-group
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_group_delete(resource_group, opts = {})
      data, _status_code, _headers = resource_group_delete_with_http_info(resource_group, opts)
      data
    end

    # delete a resource-group
    # Delete a resource-group
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_group_delete_with_http_info(resource_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_group_delete ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.resource_group_delete"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_group_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_group_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all resource-groups
    # Lists all resource groups.  A single resource group can be queried by adding its name to the resource string like:  /v1/resource-groups/rscgrp1 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :resource_groups Filter only for the specified resource groups, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<ResourceGroup>]
    def resource_group_list(opts = {})
      data, _status_code, _headers = resource_group_list_with_http_info(opts)
      data
    end

    # lists all resource-groups
    # Lists all resource groups.  A single resource group can be queried by adding its name to the resource string like:  /v1/resource-groups/rscgrp1 
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :resource_groups Filter only for the specified resource groups, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<ResourceGroup>, Integer, Hash)>] Array<ResourceGroup> data, response status code and response headers
    def resource_group_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_group_list ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.resource_group_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_group_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_group_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/resource-groups'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'resource_groups'] = @api_client.build_collection_param(opts[:'resource_groups'], :multi) if !opts[:'resource_groups'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ResourceGroup>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_group_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_group_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a resource-group
    # Sets or modifies properties  Possible properties are: - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `PeerSlotsNewResource` - range[`1-31`]      DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future  - `DrbdProxy/CompressionType` - enum     * zlib     * lzma     * lz4  - `FileSystem/Type` - enum      File system type to use      * ext4     * xfs  - `FileSystem/MkfsParams` - string      Additional parameters for the mkfs command  - `NVMe/enabled` - enum     * rdma     * tcp  - `NVMe/enabled` - range[`1-65535`] - `DrbdOptions/Disk/read-balancing` - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - `DrbdOptions/Disk/on-io-error` - enum     * pass_on     * call-local-io-error     * detach  - `DrbdOptions/Disk/disk-drain` - boolean - `DrbdOptions/Disk/resync-after` - string - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`] - `DrbdOptions/Disk/disable-write-same` - boolean - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`] - `DrbdOptions/Disk/disk-flushes` - boolean - `DrbdOptions/Disk/al-extents` - range[`67-65534`] - `DrbdOptions/Disk/al-updates` - boolean - `DrbdOptions/Disk/md-flushes` - boolean - `DrbdOptions/Disk/disk-barrier` - boolean - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean - `DrbdOptions/PeerDevice/c-fill-target` - range[`0-1048576`] - `DrbdOptions/PeerDevice/c-max-rate` - range[`250-4194304`] - `DrbdOptions/PeerDevice/resync-rate` - range[`1-8388608`] - `DrbdOptions/PeerDevice/c-delay-target` - range[`1-100`] - `DrbdOptions/PeerDevice/c-min-rate` - range[`0-4194304`] - `DrbdOptions/PeerDevice/bitmap` - boolean - `DrbdOptions/PeerDevice/c-plan-ahead` - range[`0-300`] - `DrbdOptions/Resource/peer-ack-delay` - range[`1-10000`] - `DrbdOptions/Resource/quorum-minimum-redundancy` - enum [`1-32`]     * off     * majority     * all  - `DrbdOptions/Resource/max-io-depth` - range[`4-4294967295`] - `DrbdOptions/Resource/auto-promote-timeout` - range[`0-600`] - `DrbdOptions/Resource/quorum` - enum [`1-32`]     * off     * majority     * all  - `DrbdOptions/Resource/on-no-data-accessible` - enum     * io-error     * suspend-io  - `DrbdOptions/Resource/auto-promote` - boolean - `DrbdOptions/Resource/cpu-mask` - string - `DrbdOptions/Resource/twopc-timeout` - range[`50-600`] - `DrbdOptions/Resource/twopc-retry-timeout` - range[`1-50`] - `DrbdOptions/Resource/peer-ack-window` - range[`2048-204800`] - `DrbdOptions/Resource/on-no-quorum` - enum     * io-error     * suspend-io  - `DrbdOptions/Net/max-epoch-size` - range[`1-20000`] - `DrbdOptions/Net/protocol` - enum     * A     * B     * C  - `DrbdOptions/Net/allow-two-primaries` - boolean - `DrbdOptions/Net/after-sb-0pri` - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - `DrbdOptions/Net/ko-count` - range[`0-200`] - `DrbdOptions/Net/data-integrity-alg` - string - `DrbdOptions/Net/ping-timeout` - range[`1-300`] - `DrbdOptions/Net/sndbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/transport` - string - `DrbdOptions/Net/rcvbuf-size` - range[`0-10485760`] - `DrbdOptions/Net/max-buffers` - range[`32-131072`] - `DrbdOptions/Net/fencing` - enum     * dont-care     * resource-only     * resource-and-stonith  - `DrbdOptions/Net/csums-alg` - string - `DrbdOptions/Net/always-asbp` - boolean - `DrbdOptions/Net/congestion-extents` - range[`67-65534`] - `DrbdOptions/Net/on-congestion` - enum     * block     * pull-ahead     * disconnect  - `DrbdOptions/Net/ping-int` - range[`1-120`] - `DrbdOptions/Net/rr-conflict` - enum     * disconnect     * call-pri-lost     * violently  - `DrbdOptions/Net/tcp-cork` - boolean - `DrbdOptions/Net/use-rle` - boolean - `DrbdOptions/Net/csums-after-crash-only` - boolean - `DrbdOptions/Net/socket-check-timeout` - range[`0-300`] - `DrbdOptions/Net/congestion-fill` - range[`0-20971520`] - `DrbdOptions/Net/cram-hmac-alg` - string - `DrbdOptions/Net/verify-alg` - string - `DrbdOptions/Net/shared-secret` - string - `DrbdOptions/Net/connect-int` - range[`1-120`] - `DrbdOptions/Net/timeout` - range[`1-600`] - `DrbdOptions/Net/after-sb-2pri` - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Net/after-sb-1pri` - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  - `DrbdOptions/Handlers/after-resync-target` - string - `DrbdOptions/Handlers/before-resync-target` - string - `DrbdOptions/Handlers/before-resync-source` - string - `DrbdOptions/Handlers/out-of-sync` - string - `DrbdOptions/Handlers/quorum-lost` - string - `DrbdOptions/Handlers/fence-peer` - string - `DrbdOptions/Handlers/unfence-peer` - string - `DrbdOptions/Handlers/initial-split-brain` - string - `DrbdOptions/Handlers/local-io-error` - string - `DrbdOptions/Handlers/pri-lost` - string - `DrbdOptions/Handlers/pri-lost-after-sb` - string - `DrbdOptions/Handlers/pri-on-incon-degr` - string - `DrbdOptions/Handlers/split-brain` - string 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceGroupModify] :resource_group_modify 
    # @return [ApiCallRc]
    def resource_group_modify(resource_group, opts = {})
      data, _status_code, _headers = resource_group_modify_with_http_info(resource_group, opts)
      data
    end

    # modify a resource-group
    # Sets or modifies properties  Possible properties are: - &#x60;StorPoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;PeerSlotsNewResource&#x60; - range[&#x60;1-31&#x60;]      DRBD peer slots to allocate for newly created resources (default 7), the number of peer slots cannot be changed once the resource is created, so allow sufficient slots to increase redundancy in the future  - &#x60;DrbdProxy/CompressionType&#x60; - enum     * zlib     * lzma     * lz4  - &#x60;FileSystem/Type&#x60; - enum      File system type to use      * ext4     * xfs  - &#x60;FileSystem/MkfsParams&#x60; - string      Additional parameters for the mkfs command  - &#x60;NVMe/enabled&#x60; - enum     * rdma     * tcp  - &#x60;NVMe/enabled&#x60; - range[&#x60;1-65535&#x60;] - &#x60;DrbdOptions/Disk/read-balancing&#x60; - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - &#x60;DrbdOptions/Disk/on-io-error&#x60; - enum     * pass_on     * call-local-io-error     * detach  - &#x60;DrbdOptions/Disk/disk-drain&#x60; - boolean - &#x60;DrbdOptions/Disk/resync-after&#x60; - string - &#x60;DrbdOptions/Disk/disk-timeout&#x60; - range[&#x60;0-6000&#x60;] - &#x60;DrbdOptions/Disk/disable-write-same&#x60; - boolean - &#x60;DrbdOptions/Disk/rs-discard-granularity&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/Disk/disk-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/al-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Disk/al-updates&#x60; - boolean - &#x60;DrbdOptions/Disk/md-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/disk-barrier&#x60; - boolean - &#x60;DrbdOptions/Disk/discard-zeroes-if-aligned&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-fill-target&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/PeerDevice/c-max-rate&#x60; - range[&#x60;250-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/resync-rate&#x60; - range[&#x60;1-8388608&#x60;] - &#x60;DrbdOptions/PeerDevice/c-delay-target&#x60; - range[&#x60;1-100&#x60;] - &#x60;DrbdOptions/PeerDevice/c-min-rate&#x60; - range[&#x60;0-4194304&#x60;] - &#x60;DrbdOptions/PeerDevice/bitmap&#x60; - boolean - &#x60;DrbdOptions/PeerDevice/c-plan-ahead&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Resource/peer-ack-delay&#x60; - range[&#x60;1-10000&#x60;] - &#x60;DrbdOptions/Resource/quorum-minimum-redundancy&#x60; - enum [&#x60;1-32&#x60;]     * off     * majority     * all  - &#x60;DrbdOptions/Resource/max-io-depth&#x60; - range[&#x60;4-4294967295&#x60;] - &#x60;DrbdOptions/Resource/auto-promote-timeout&#x60; - range[&#x60;0-600&#x60;] - &#x60;DrbdOptions/Resource/quorum&#x60; - enum [&#x60;1-32&#x60;]     * off     * majority     * all  - &#x60;DrbdOptions/Resource/on-no-data-accessible&#x60; - enum     * io-error     * suspend-io  - &#x60;DrbdOptions/Resource/auto-promote&#x60; - boolean - &#x60;DrbdOptions/Resource/cpu-mask&#x60; - string - &#x60;DrbdOptions/Resource/twopc-timeout&#x60; - range[&#x60;50-600&#x60;] - &#x60;DrbdOptions/Resource/twopc-retry-timeout&#x60; - range[&#x60;1-50&#x60;] - &#x60;DrbdOptions/Resource/peer-ack-window&#x60; - range[&#x60;2048-204800&#x60;] - &#x60;DrbdOptions/Resource/on-no-quorum&#x60; - enum     * io-error     * suspend-io  - &#x60;DrbdOptions/Net/max-epoch-size&#x60; - range[&#x60;1-20000&#x60;] - &#x60;DrbdOptions/Net/protocol&#x60; - enum     * A     * B     * C  - &#x60;DrbdOptions/Net/allow-two-primaries&#x60; - boolean - &#x60;DrbdOptions/Net/after-sb-0pri&#x60; - enum     * disconnect     * discard-younger-primary     * discard-older-primary     * discard-zero-changes     * discard-least-changes     * discard-local     * discard-remote  - &#x60;DrbdOptions/Net/ko-count&#x60; - range[&#x60;0-200&#x60;] - &#x60;DrbdOptions/Net/data-integrity-alg&#x60; - string - &#x60;DrbdOptions/Net/ping-timeout&#x60; - range[&#x60;1-300&#x60;] - &#x60;DrbdOptions/Net/sndbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/transport&#x60; - string - &#x60;DrbdOptions/Net/rcvbuf-size&#x60; - range[&#x60;0-10485760&#x60;] - &#x60;DrbdOptions/Net/max-buffers&#x60; - range[&#x60;32-131072&#x60;] - &#x60;DrbdOptions/Net/fencing&#x60; - enum     * dont-care     * resource-only     * resource-and-stonith  - &#x60;DrbdOptions/Net/csums-alg&#x60; - string - &#x60;DrbdOptions/Net/always-asbp&#x60; - boolean - &#x60;DrbdOptions/Net/congestion-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Net/on-congestion&#x60; - enum     * block     * pull-ahead     * disconnect  - &#x60;DrbdOptions/Net/ping-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/rr-conflict&#x60; - enum     * disconnect     * call-pri-lost     * violently  - &#x60;DrbdOptions/Net/tcp-cork&#x60; - boolean - &#x60;DrbdOptions/Net/use-rle&#x60; - boolean - &#x60;DrbdOptions/Net/csums-after-crash-only&#x60; - boolean - &#x60;DrbdOptions/Net/socket-check-timeout&#x60; - range[&#x60;0-300&#x60;] - &#x60;DrbdOptions/Net/congestion-fill&#x60; - range[&#x60;0-20971520&#x60;] - &#x60;DrbdOptions/Net/cram-hmac-alg&#x60; - string - &#x60;DrbdOptions/Net/verify-alg&#x60; - string - &#x60;DrbdOptions/Net/shared-secret&#x60; - string - &#x60;DrbdOptions/Net/connect-int&#x60; - range[&#x60;1-120&#x60;] - &#x60;DrbdOptions/Net/timeout&#x60; - range[&#x60;1-600&#x60;] - &#x60;DrbdOptions/Net/after-sb-2pri&#x60; - enum     * disconnect     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Net/after-sb-1pri&#x60; - enum     * disconnect     * consensus     * discard-secondary     * call-pri-lost-after-sb     * violently-as0p  - &#x60;DrbdOptions/Handlers/after-resync-target&#x60; - string - &#x60;DrbdOptions/Handlers/before-resync-target&#x60; - string - &#x60;DrbdOptions/Handlers/before-resync-source&#x60; - string - &#x60;DrbdOptions/Handlers/out-of-sync&#x60; - string - &#x60;DrbdOptions/Handlers/quorum-lost&#x60; - string - &#x60;DrbdOptions/Handlers/fence-peer&#x60; - string - &#x60;DrbdOptions/Handlers/unfence-peer&#x60; - string - &#x60;DrbdOptions/Handlers/initial-split-brain&#x60; - string - &#x60;DrbdOptions/Handlers/local-io-error&#x60; - string - &#x60;DrbdOptions/Handlers/pri-lost&#x60; - string - &#x60;DrbdOptions/Handlers/pri-lost-after-sb&#x60; - string - &#x60;DrbdOptions/Handlers/pri-on-incon-degr&#x60; - string - &#x60;DrbdOptions/Handlers/split-brain&#x60; - string 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceGroupModify] :resource_group_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_group_modify_with_http_info(resource_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_group_modify ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.resource_group_modify"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_group_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_group_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_group_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # create a new resource-definition based on the given resource-group
    # Creates a new resource-definition and auto-deploys if configured to do so. 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceGroupSpawn] :resource_group_spawn 
    # @return [ApiCallRc]
    def resource_group_spawn(resource_group, opts = {})
      data, _status_code, _headers = resource_group_spawn_with_http_info(resource_group, opts)
      data
    end

    # create a new resource-definition based on the given resource-group
    # Creates a new resource-definition and auto-deploys if configured to do so. 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceGroupSpawn] :resource_group_spawn 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_group_spawn_with_http_info(resource_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_group_spawn ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.resource_group_spawn"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}/spawn'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_group_spawn'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_group_spawn",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_group_spawn\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all resources for a resource-definition
    # Lists all resources for a resource-definition.  A single resource can be queried by adding its name to the resource string like:  /v1/resource-definitions/rsc1/resources/nodeA 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<Resource>]
    def resource_list(resource, opts = {})
      data, _status_code, _headers = resource_list_with_http_info(resource, opts)
      data
    end

    # lists all resources for a resource-definition
    # Lists all resources for a resource-definition.  A single resource can be queried by adding its name to the resource string like:  /v1/resource-definitions/rsc1/resources/nodeA 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<Resource>, Integer, Hash)>] Array<Resource> data, response status code and response headers
    def resource_list_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_list"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.resource_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Resource>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # migrate a resource to another node
    # migrate a resource to another node without reducing the redundancy count 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param fromnode [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_migrate_disk(resource, node, fromnode, opts = {})
      data, _status_code, _headers = resource_migrate_disk_with_http_info(resource, node, fromnode, opts)
      data
    end

    # migrate a resource to another node
    # migrate a resource to another node without reducing the redundancy count 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param fromnode [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_migrate_disk_with_http_info(resource, node, fromnode, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_migrate_disk ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_migrate_disk"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_migrate_disk"
      end
      # verify the required parameter 'fromnode' is set
      if @api_client.config.client_side_validation && fromnode.nil?
        fail ArgumentError, "Missing the required parameter 'fromnode' when calling DevelopersApi.resource_migrate_disk"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/migrate-disk/{fromnode}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'fromnode' + '}', CGI.escape(fromnode.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_migrate_disk",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_migrate_disk\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # migrate a resource to another node
    # migrate a resource to another node without reducing the redundency count 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param fromnode [String] 
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_migrate_disk_storagepool(resource, node, fromnode, storagepool, opts = {})
      data, _status_code, _headers = resource_migrate_disk_storagepool_with_http_info(resource, node, fromnode, storagepool, opts)
      data
    end

    # migrate a resource to another node
    # migrate a resource to another node without reducing the redundency count 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param fromnode [String] 
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_migrate_disk_storagepool_with_http_info(resource, node, fromnode, storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_migrate_disk_storagepool ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_migrate_disk_storagepool"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_migrate_disk_storagepool"
      end
      # verify the required parameter 'fromnode' is set
      if @api_client.config.client_side_validation && fromnode.nil?
        fail ArgumentError, "Missing the required parameter 'fromnode' when calling DevelopersApi.resource_migrate_disk_storagepool"
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.resource_migrate_disk_storagepool"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/migrate-disk/{fromnode}/{storagepool}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'fromnode' + '}', CGI.escape(fromnode.to_s)).sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_migrate_disk_storagepool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_migrate_disk_storagepool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a resource
    # Sets or modifies properties  Possible properties are: - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `DrbdMetaType` - enum     * external     * internal  - `PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Preferred network interface to use  - `PeerSlots` - range[`1-31`]      DRBD peer slots present on resource  - `FileSystem/Type` - enum      File system type to use      * ext4     * xfs  - `FileSystem/MkfsParams` - string      Additional parameters for the mkfs command  - `NVMe/PrefNic` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Preferred network interface to use  - `sys/fs/blkio_throttle_read` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - `sys/fs/blkio_throttle_write` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceModify] :resource_modify 
    # @return [ApiCallRc]
    def resource_modify(resource, node, opts = {})
      data, _status_code, _headers = resource_modify_with_http_info(resource, node, opts)
      data
    end

    # modify a resource
    # Sets or modifies properties  Possible properties are: - &#x60;StorPoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;StorPoolNameDrbdMeta&#x60; - regex[&#x60;^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;DrbdMetaType&#x60; - enum     * external     * internal  - &#x60;PrefNic&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Preferred network interface to use  - &#x60;PeerSlots&#x60; - range[&#x60;1-31&#x60;]      DRBD peer slots present on resource  - &#x60;FileSystem/Type&#x60; - enum      File system type to use      * ext4     * xfs  - &#x60;FileSystem/MkfsParams&#x60; - string      Additional parameters for the mkfs command  - &#x60;NVMe/PrefNic&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Preferred network interface to use  - &#x60;sys/fs/blkio_throttle_read&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - &#x60;sys/fs/blkio_throttle_write&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [ResourceModify] :resource_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_modify_with_http_info(resource, node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_modify ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_modify"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_modify"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'resource_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # create a snapshot
    # Create a snapshot for a resource
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Snapshot] :snapshot 
    # @return [ApiCallRc]
    def resource_snapshot_create(resource, opts = {})
      data, _status_code, _headers = resource_snapshot_create_with_http_info(resource, opts)
      data
    end

    # create a snapshot
    # Create a snapshot for a resource
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Snapshot] :snapshot 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_snapshot_create_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshot_create ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshot_create"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshots'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'snapshot'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshot_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshot_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a snapshot
    # Delete a snapshot
    # @param resource [String] resource to use
    # @param snapshot [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_snapshot_delete(resource, snapshot, opts = {})
      data, _status_code, _headers = resource_snapshot_delete_with_http_info(resource, snapshot, opts)
      data
    end

    # delete a snapshot
    # Delete a snapshot
    # @param resource [String] resource to use
    # @param snapshot [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_snapshot_delete_with_http_info(resource, snapshot, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshot_delete ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshot_delete"
      end
      # verify the required parameter 'snapshot' is set
      if @api_client.config.client_side_validation && snapshot.nil?
        fail ArgumentError, "Missing the required parameter 'snapshot' when calling DevelopersApi.resource_snapshot_delete"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshots/{snapshot}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'snapshot' + '}', CGI.escape(snapshot.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshot_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshot_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # list a specific snapshot
    # List the given snapshot for a resource
    # @param resource [String] resource to use
    # @param snapshot [String] 
    # @param [Hash] opts the optional parameters
    # @return [Snapshot]
    def resource_snapshot_list(resource, snapshot, opts = {})
      data, _status_code, _headers = resource_snapshot_list_with_http_info(resource, snapshot, opts)
      data
    end

    # list a specific snapshot
    # List the given snapshot for a resource
    # @param resource [String] resource to use
    # @param snapshot [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Snapshot, Integer, Hash)>] Snapshot data, response status code and response headers
    def resource_snapshot_list_with_http_info(resource, snapshot, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshot_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshot_list"
      end
      # verify the required parameter 'snapshot' is set
      if @api_client.config.client_side_validation && snapshot.nil?
        fail ArgumentError, "Missing the required parameter 'snapshot' when calling DevelopersApi.resource_snapshot_list"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshots/{snapshot}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'snapshot' + '}', CGI.escape(snapshot.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Snapshot'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshot_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshot_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # restore a snapshot
    # Restore a snapshot to a new resource
    # @param resource [String] resource to use
    # @param snapshot [String] Snapshot name to use
    # @param [Hash] opts the optional parameters
    # @option opts [SnapshotRestore] :snapshot_restore 
    # @return [ApiCallRc]
    def resource_snapshot_restore(resource, snapshot, opts = {})
      data, _status_code, _headers = resource_snapshot_restore_with_http_info(resource, snapshot, opts)
      data
    end

    # restore a snapshot
    # Restore a snapshot to a new resource
    # @param resource [String] resource to use
    # @param snapshot [String] Snapshot name to use
    # @param [Hash] opts the optional parameters
    # @option opts [SnapshotRestore] :snapshot_restore 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_snapshot_restore_with_http_info(resource, snapshot, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshot_restore ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshot_restore"
      end
      # verify the required parameter 'snapshot' is set
      if @api_client.config.client_side_validation && snapshot.nil?
        fail ArgumentError, "Missing the required parameter 'snapshot' when calling DevelopersApi.resource_snapshot_restore"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshot-restore-resource/{snapshot}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'snapshot' + '}', CGI.escape(snapshot.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'snapshot_restore'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshot_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshot_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # rollback a snapshot
    # Rollback a resource to the snapshot state
    # @param resource [String] resource to use
    # @param snapshot [String] Snapshot name to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_snapshot_rollback(resource, snapshot, opts = {})
      data, _status_code, _headers = resource_snapshot_rollback_with_http_info(resource, snapshot, opts)
      data
    end

    # rollback a snapshot
    # Rollback a resource to the snapshot state
    # @param resource [String] resource to use
    # @param snapshot [String] Snapshot name to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_snapshot_rollback_with_http_info(resource, snapshot, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshot_rollback ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshot_rollback"
      end
      # verify the required parameter 'snapshot' is set
      if @api_client.config.client_side_validation && snapshot.nil?
        fail ArgumentError, "Missing the required parameter 'snapshot' when calling DevelopersApi.resource_snapshot_rollback"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshot-rollback/{snapshot}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'snapshot' + '}', CGI.escape(snapshot.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshot_rollback",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshot_rollback\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # list snapshots
    # List snapshots for a resource
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @return [Array<Snapshot>]
    def resource_snapshots_list(resource, opts = {})
      data, _status_code, _headers = resource_snapshots_list_with_http_info(resource, opts)
      data
    end

    # list snapshots
    # List snapshots for a resource
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Snapshot>, Integer, Hash)>] Array<Snapshot> data, response status code and response headers
    def resource_snapshots_list_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshots_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshots_list"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshots'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Snapshot>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshots_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshots_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # restore a snapshot volume definition
    # Restore a snapshot volume definition to a new resource
    # @param resource [String] resource to use
    # @param snapshot [String] Snapshot name to use
    # @param [Hash] opts the optional parameters
    # @option opts [SnapshotRestore] :snapshot_restore 
    # @return [ApiCallRc]
    def resource_snapshots_restore_volume_definition(resource, snapshot, opts = {})
      data, _status_code, _headers = resource_snapshots_restore_volume_definition_with_http_info(resource, snapshot, opts)
      data
    end

    # restore a snapshot volume definition
    # Restore a snapshot volume definition to a new resource
    # @param resource [String] resource to use
    # @param snapshot [String] Snapshot name to use
    # @param [Hash] opts the optional parameters
    # @option opts [SnapshotRestore] :snapshot_restore 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_snapshots_restore_volume_definition_with_http_info(resource, snapshot, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_snapshots_restore_volume_definition ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_snapshots_restore_volume_definition"
      end
      # verify the required parameter 'snapshot' is set
      if @api_client.config.client_side_validation && snapshot.nil?
        fail ArgumentError, "Missing the required parameter 'snapshot' when calling DevelopersApi.resource_snapshots_restore_volume_definition"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/snapshot-restore-volume-definition/{snapshot}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'snapshot' + '}', CGI.escape(snapshot.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'snapshot_restore'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_snapshots_restore_volume_definition",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_snapshots_restore_volume_definition\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # toggle a resource to a diskful resource
    # toggle a resource to a diskful resource using the default storage pool 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_toggle_diskful(resource, node, opts = {})
      data, _status_code, _headers = resource_toggle_diskful_with_http_info(resource, node, opts)
      data
    end

    # toggle a resource to a diskful resource
    # toggle a resource to a diskful resource using the default storage pool 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_toggle_diskful_with_http_info(resource, node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_toggle_diskful ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_toggle_diskful"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_toggle_diskful"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskful'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_toggle_diskful",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_toggle_diskful\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # toggle a resource to a diskful resource
    # toggle a resource to a diskful resource
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_toggle_diskful_storagepool(resource, node, storagepool, opts = {})
      data, _status_code, _headers = resource_toggle_diskful_storagepool_with_http_info(resource, node, storagepool, opts)
      data
    end

    # toggle a resource to a diskful resource
    # toggle a resource to a diskful resource
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_toggle_diskful_storagepool_with_http_info(resource, node, storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_toggle_diskful_storagepool ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_toggle_diskful_storagepool"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_toggle_diskful_storagepool"
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.resource_toggle_diskful_storagepool"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskful/{storagepool}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_toggle_diskful_storagepool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_toggle_diskful_storagepool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # toggle a resource to diskless
    # toggle a resource to a diskless resource
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_toggle_diskless(resource, node, opts = {})
      data, _status_code, _headers = resource_toggle_diskless_with_http_info(resource, node, opts)
      data
    end

    # toggle a resource to diskless
    # toggle a resource to a diskless resource
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_toggle_diskless_with_http_info(resource, node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_toggle_diskless ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_toggle_diskless"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_toggle_diskless"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskless'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_toggle_diskless",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_toggle_diskless\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # toggle a resource to diskless resource
    # toggle a resource to a diskless. 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param disklesspool [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def resource_toggle_diskless_disklesspool(resource, node, disklesspool, opts = {})
      data, _status_code, _headers = resource_toggle_diskless_disklesspool_with_http_info(resource, node, disklesspool, opts)
      data
    end

    # toggle a resource to diskless resource
    # toggle a resource to a diskless. 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param disklesspool [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def resource_toggle_diskless_disklesspool_with_http_info(resource, node, disklesspool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_toggle_diskless_disklesspool ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_toggle_diskless_disklesspool"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_toggle_diskless_disklesspool"
      end
      # verify the required parameter 'disklesspool' is set
      if @api_client.config.client_side_validation && disklesspool.nil?
        fail ArgumentError, "Missing the required parameter 'disklesspool' when calling DevelopersApi.resource_toggle_diskless_disklesspool"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/toggle-disk/diskless/{disklesspool}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'disklesspool' + '}', CGI.escape(disklesspool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_toggle_diskless_disklesspool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_toggle_diskless_disklesspool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all volumes of a resources
    # Lists all volumes for a resource-definition.  A single volume can be queried by adding its volume number to the resource string like:  /v1/resource-definitions/rsc1/resources/nodeA/volumes/0 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<Volume>]
    def resource_volume_list(resource, node, opts = {})
      data, _status_code, _headers = resource_volume_list_with_http_info(resource, node, opts)
      data
    end

    # lists all volumes of a resources
    # Lists all volumes for a resource-definition.  A single volume can be queried by adding its volume number to the resource string like:  /v1/resource-definitions/rsc1/resources/nodeA/volumes/0 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<Volume>, Integer, Hash)>] Array<Volume> data, response status code and response headers
    def resource_volume_list_with_http_info(resource, node, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.resource_volume_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.resource_volume_list"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.resource_volume_list"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.resource_volume_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_volume_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.resource_volume_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/volumes'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Volume>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.resource_volume_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#resource_volume_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a storage pool definition
    # Sets or modifies properties  Possible properties are: - `MaxOversubscriptionRatio` - range[`1-1000`] 
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePoolDefinitionModify] :storage_pool_definition_modify 
    # @return [ApiCallRc]
    def stor_pool_dfn_modify(storagepool, opts = {})
      data, _status_code, _headers = stor_pool_dfn_modify_with_http_info(storagepool, opts)
      data
    end

    # modify a storage pool definition
    # Sets or modifies properties  Possible properties are: - &#x60;MaxOversubscriptionRatio&#x60; - range[&#x60;1-1000&#x60;] 
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePoolDefinitionModify] :storage_pool_definition_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def stor_pool_dfn_modify_with_http_info(storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.stor_pool_dfn_modify ...'
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.stor_pool_dfn_modify"
      end
      # resource path
      local_var_path = '/v1/storage-pool-definitions/{storagepool}'.sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'storage_pool_definition_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.stor_pool_dfn_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#stor_pool_dfn_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a storage pool definition
    # Delete a storage pool definition from Linstor
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def storage_pool_definition_delete(storagepool, opts = {})
      data, _status_code, _headers = storage_pool_definition_delete_with_http_info(storagepool, opts)
      data
    end

    # delete a storage pool definition
    # Delete a storage pool definition from Linstor
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def storage_pool_definition_delete_with_http_info(storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.storage_pool_definition_delete ...'
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.storage_pool_definition_delete"
      end
      # resource path
      local_var_path = '/v1/storage-pool-definitions/{storagepool}'.sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.storage_pool_definition_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#storage_pool_definition_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # add a storage pool definition to Linstor
    # Adds a storage pool definition to Linstor 
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePoolDefinition] :storage_pool_definition Storage pool definition to add
    # @return [ApiCallRc]
    def storage_pool_dfn_add(opts = {})
      data, _status_code, _headers = storage_pool_dfn_add_with_http_info(opts)
      data
    end

    # add a storage pool definition to Linstor
    # Adds a storage pool definition to Linstor 
    # @param [Hash] opts the optional parameters
    # @option opts [StoragePoolDefinition] :storage_pool_definition Storage pool definition to add
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def storage_pool_dfn_add_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.storage_pool_dfn_add ...'
      end
      # resource path
      local_var_path = '/v1/storage-pool-definitions'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'storage_pool_definition'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.storage_pool_dfn_add",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#storage_pool_dfn_add\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Lists a specific storage pool definition
    # Returns a specific storage pool definition
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [StoragePoolDefinition]
    def storage_pool_dfn_get(storagepool, opts = {})
      data, _status_code, _headers = storage_pool_dfn_get_with_http_info(storagepool, opts)
      data
    end

    # Lists a specific storage pool definition
    # Returns a specific storage pool definition
    # @param storagepool [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(StoragePoolDefinition, Integer, Hash)>] StoragePoolDefinition data, response status code and response headers
    def storage_pool_dfn_get_with_http_info(storagepool, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.storage_pool_dfn_get ...'
      end
      # verify the required parameter 'storagepool' is set
      if @api_client.config.client_side_validation && storagepool.nil?
        fail ArgumentError, "Missing the required parameter 'storagepool' when calling DevelopersApi.storage_pool_dfn_get"
      end
      # resource path
      local_var_path = '/v1/storage-pool-definitions/{storagepool}'.sub('{' + 'storagepool' + '}', CGI.escape(storagepool.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'StoragePoolDefinition'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.storage_pool_dfn_get",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#storage_pool_dfn_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Lists storage pool definitions
    # Returns an array of all storage pool definitions
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<StoragePoolDefinition>]
    def storage_pool_dfn_list(opts = {})
      data, _status_code, _headers = storage_pool_dfn_list_with_http_info(opts)
      data
    end

    # Lists storage pool definitions
    # Returns an array of all storage pool definitions
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<StoragePoolDefinition>, Integer, Hash)>] Array<StoragePoolDefinition> data, response status code and response headers
    def storage_pool_dfn_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.storage_pool_dfn_list ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.storage_pool_dfn_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.storage_pool_dfn_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.storage_pool_dfn_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/storage-pool-definitions'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<StoragePoolDefinition>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.storage_pool_dfn_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#storage_pool_dfn_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # show physical storage on nodes, to be used with LINSTOR
    # Gives a grouped list of physical storage that can be turned into a LINSTOR storage-pool
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<PhysicalStorage>]
    def view_physica_storage(opts = {})
      data, _status_code, _headers = view_physica_storage_with_http_info(opts)
      data
    end

    # show physical storage on nodes, to be used with LINSTOR
    # Gives a grouped list of physical storage that can be turned into a LINSTOR storage-pool
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<PhysicalStorage>, Integer, Hash)>] Array<PhysicalStorage> data, response status code and response headers
    def view_physica_storage_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.view_physica_storage ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.view_physica_storage, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.view_physica_storage, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.view_physica_storage, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/physical-storage'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<PhysicalStorage>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.view_physica_storage",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#view_physica_storage\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # query all resources with their volumes
    # This REST-resource should be used if you want to get an overview of all resources with their volumes.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :nodes Filter only for the specified nodes, if not specified no filtering.
    # @option opts [Array<String>] :storage_pools Filter only for the specified storage pools, if not specified no filtering.
    # @option opts [Array<String>] :resources Filter only for the specified resources, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<ResourceWithVolumes>]
    def view_resources(opts = {})
      data, _status_code, _headers = view_resources_with_http_info(opts)
      data
    end

    # query all resources with their volumes
    # This REST-resource should be used if you want to get an overview of all resources with their volumes.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :nodes Filter only for the specified nodes, if not specified no filtering.
    # @option opts [Array<String>] :storage_pools Filter only for the specified storage pools, if not specified no filtering.
    # @option opts [Array<String>] :resources Filter only for the specified resources, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<ResourceWithVolumes>, Integer, Hash)>] Array<ResourceWithVolumes> data, response status code and response headers
    def view_resources_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.view_resources ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.view_resources, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.view_resources, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.view_resources, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/view/resources'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'nodes'] = @api_client.build_collection_param(opts[:'nodes'], :multi) if !opts[:'nodes'].nil?
      query_params[:'storage_pools'] = @api_client.build_collection_param(opts[:'storage_pools'], :multi) if !opts[:'storage_pools'].nil?
      query_params[:'resources'] = @api_client.build_collection_param(opts[:'resources'], :multi) if !opts[:'resources'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ResourceWithVolumes>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.view_resources",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#view_resources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # query all storage pools
    # This REST-resource should be used if you want to get an overview of all storage pools.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :nodes Filter only for the specified nodes, if not specified no filtering.
    # @option opts [Array<String>] :storage_pools Filter only for the specified storage pools, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<StoragePool>]
    def view_storage_pools(opts = {})
      data, _status_code, _headers = view_storage_pools_with_http_info(opts)
      data
    end

    # query all storage pools
    # This REST-resource should be used if you want to get an overview of all storage pools.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :nodes Filter only for the specified nodes, if not specified no filtering.
    # @option opts [Array<String>] :storage_pools Filter only for the specified storage pools, if not specified no filtering.
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<StoragePool>, Integer, Hash)>] Array<StoragePool> data, response status code and response headers
    def view_storage_pools_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.view_storage_pools ...'
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.view_storage_pools, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.view_storage_pools, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.view_storage_pools, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/view/storage-pools'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'nodes'] = @api_client.build_collection_param(opts[:'nodes'], :multi) if !opts[:'nodes'].nil?
      query_params[:'storage_pools'] = @api_client.build_collection_param(opts[:'storage_pools'], :multi) if !opts[:'storage_pools'].nil?
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<StoragePool>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.view_storage_pools",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#view_storage_pools\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # add a volume-definition to a resource
    # Adds a volume-definition.  Required properties is only `size`, all other will be auto generated if not given. 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeDefinitionCreate] :volume_definition_create 
    # @return [ApiCallRc]
    def volume_definition_create(resource, opts = {})
      data, _status_code, _headers = volume_definition_create_with_http_info(resource, opts)
      data
    end

    # add a volume-definition to a resource
    # Adds a volume-definition.  Required properties is only &#x60;size&#x60;, all other will be auto generated if not given. 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeDefinitionCreate] :volume_definition_create 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_definition_create_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_definition_create ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.volume_definition_create"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/volume-definitions'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'volume_definition_create'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_definition_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_definition_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a volume-definition
    # Delete a volume-definition
    # @param resource [String] resource to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def volume_definition_delete(resource, volume_number, opts = {})
      data, _status_code, _headers = volume_definition_delete_with_http_info(resource, volume_number, opts)
      data
    end

    # delete a volume-definition
    # Delete a volume-definition
    # @param resource [String] resource to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_definition_delete_with_http_info(resource, volume_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_definition_delete ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.volume_definition_delete"
      end
      # verify the required parameter 'volume_number' is set
      if @api_client.config.client_side_validation && volume_number.nil?
        fail ArgumentError, "Missing the required parameter 'volume_number' when calling DevelopersApi.volume_definition_delete"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/volume-definitions/{volume_number}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'volume_number' + '}', CGI.escape(volume_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_definition_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_definition_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all volume-definitions
    # Lists all volume definitions.  A single volume definition can be queried by adding its name to the resource string like:  /v1/resource-definitions/rsc1/volume-definitions/0 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<VolumeDefinition>]
    def volume_definition_list(resource, opts = {})
      data, _status_code, _headers = volume_definition_list_with_http_info(resource, opts)
      data
    end

    # lists all volume-definitions
    # Lists all volume definitions.  A single volume definition can be queried by adding its name to the resource string like:  /v1/resource-definitions/rsc1/volume-definitions/0 
    # @param resource [String] resource to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<VolumeDefinition>, Integer, Hash)>] Array<VolumeDefinition> data, response status code and response headers
    def volume_definition_list_with_http_info(resource, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_definition_list ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.volume_definition_list"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.volume_definition_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.volume_definition_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.volume_definition_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/volume-definitions'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<VolumeDefinition>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_definition_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_definition_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a volume-definition
    # Sets or modifies properties  Possible properties are: - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `StorPoolNameDrbdMeta` - regex[`^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `DrbdMetaType` - enum     * external     * internal  - `OverrideVlmId` - regex[`.*`]      Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes  - `AllowLargerVolumeSize` - boolean_true_false      Do not fail when the underlying volume is larger than expected  - `FileSystem/Type` - enum      File system type to use      * ext4     * xfs  - `FileSystem/MkfsParams` - string      Additional parameters for the mkfs command  - `StorDriver/LvcreateType` - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`] - `sys/fs/blkio_throttle_read` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - `sys/fs/blkio_throttle_write` - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - `Writecache/PoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name for writecache  - `Writecache/Size` - regex[`^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$`]      Size of the writecache in % (0-100) or KiB otherwise  - `Writecache/Blocksize` - long      4096 is recommended; the maximum block size is the page size  - `Writecache/Options/StartSector` - long      offset from the start of cache device in 512-byte sectors  - `Writecache/Options/HighWatermark` - long      start writeback when the number of used blocks reach this watermark  - `Writecache/Options/LowWatermark` - long      stop writeback when the number of used blocks drops below this watermark  - `Writecache/Options/WritebackJobs` - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - `Writecache/Options/AutocommitBlocks` - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - `Writecache/Options/AutocommitTime` - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - `Writecache/Options/Fua` - enum      \"On\" results in \"fua\" as argument, whereas the value \"Off\" results in \"nofua\" argument      * On     * Off  - `Writecache/Options/Additional` - string      Additional arguments passed through  - `DrbdOptions/Disk/read-balancing` - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - `DrbdOptions/Disk/on-io-error` - enum     * pass_on     * call-local-io-error     * detach  - `DrbdOptions/Disk/disk-drain` - boolean - `DrbdOptions/Disk/resync-after` - string - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`] - `DrbdOptions/Disk/disable-write-same` - boolean - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`] - `DrbdOptions/Disk/disk-flushes` - boolean - `DrbdOptions/Disk/al-extents` - range[`67-65534`] - `DrbdOptions/Disk/al-updates` - boolean - `DrbdOptions/Disk/md-flushes` - boolean - `DrbdOptions/Disk/disk-barrier` - boolean - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean 
    # @param resource [String] resource to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeDefinitionModify] :volume_definition_modify 
    # @return [ApiCallRc]
    def volume_definition_modify(resource, volume_number, opts = {})
      data, _status_code, _headers = volume_definition_modify_with_http_info(resource, volume_number, opts)
      data
    end

    # modify a volume-definition
    # Sets or modifies properties  Possible properties are: - &#x60;StorPoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;StorPoolNameDrbdMeta&#x60; - regex[&#x60;^|.internal|[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;DrbdMetaType&#x60; - enum     * external     * internal  - &#x60;OverrideVlmId&#x60; - regex[&#x60;.*&#x60;]      Overwrites the generated &#39;&lt;resource-name&gt;_&lt;5 digit volume number&gt;&#39; volume name for migration purposes  - &#x60;AllowLargerVolumeSize&#x60; - boolean_true_false      Do not fail when the underlying volume is larger than expected  - &#x60;FileSystem/Type&#x60; - enum      File system type to use      * ext4     * xfs  - &#x60;FileSystem/MkfsParams&#x60; - string      Additional parameters for the mkfs command  - &#x60;StorDriver/LvcreateType&#x60; - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - &#x60;DrbdCurrentGi&#x60; - regex[&#x60;[a-fA-F0-9]{16}&#x60;] - &#x60;sys/fs/blkio_throttle_read&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.read_bps_device  - &#x60;sys/fs/blkio_throttle_write&#x60; - long      Sets the /sys/fs/cgroup/blkio/blkio.throttle.write_bps_device  - &#x60;Writecache/PoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name for writecache  - &#x60;Writecache/Size&#x60; - regex[&#x60;^100%|[0-9]{1,2}([.][0-9]*)?%|[1-9][0-9]{2,}$&#x60;]      Size of the writecache in % (0-100) or KiB otherwise  - &#x60;Writecache/Blocksize&#x60; - long      4096 is recommended; the maximum block size is the page size  - &#x60;Writecache/Options/StartSector&#x60; - long      offset from the start of cache device in 512-byte sectors  - &#x60;Writecache/Options/HighWatermark&#x60; - long      start writeback when the number of used blocks reach this watermark  - &#x60;Writecache/Options/LowWatermark&#x60; - long      stop writeback when the number of used blocks drops below this watermark  - &#x60;Writecache/Options/WritebackJobs&#x60; - long      limit the number of blocks that are in flight during writeback. Setting this value reduces writeback throughput, but it may improve latency of read requests  - &#x60;Writecache/Options/AutocommitBlocks&#x60; - long      when the application writes this amount of blocks without issuing the FLUSH request, the blocks are automatically commited  - &#x60;Writecache/Options/AutocommitTime&#x60; - long      autocommit time in milliseconds. The data is automatically commited if this time passes and no FLUSH request is received  - &#x60;Writecache/Options/Fua&#x60; - enum      \&quot;On\&quot; results in \&quot;fua\&quot; as argument, whereas the value \&quot;Off\&quot; results in \&quot;nofua\&quot; argument      * On     * Off  - &#x60;Writecache/Options/Additional&#x60; - string      Additional arguments passed through  - &#x60;DrbdOptions/Disk/read-balancing&#x60; - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - &#x60;DrbdOptions/Disk/on-io-error&#x60; - enum     * pass_on     * call-local-io-error     * detach  - &#x60;DrbdOptions/Disk/disk-drain&#x60; - boolean - &#x60;DrbdOptions/Disk/resync-after&#x60; - string - &#x60;DrbdOptions/Disk/disk-timeout&#x60; - range[&#x60;0-6000&#x60;] - &#x60;DrbdOptions/Disk/disable-write-same&#x60; - boolean - &#x60;DrbdOptions/Disk/rs-discard-granularity&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/Disk/disk-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/al-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Disk/al-updates&#x60; - boolean - &#x60;DrbdOptions/Disk/md-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/disk-barrier&#x60; - boolean - &#x60;DrbdOptions/Disk/discard-zeroes-if-aligned&#x60; - boolean 
    # @param resource [String] resource to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeDefinitionModify] :volume_definition_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_definition_modify_with_http_info(resource, volume_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_definition_modify ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.volume_definition_modify"
      end
      # verify the required parameter 'volume_number' is set
      if @api_client.config.client_side_validation && volume_number.nil?
        fail ArgumentError, "Missing the required parameter 'volume_number' when calling DevelopersApi.volume_definition_modify"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/volume-definitions/{volume_number}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'volume_number' + '}', CGI.escape(volume_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'volume_definition_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_definition_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_definition_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # add a volume-group to a resource-group
    # Adds a volume-group. 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeGroup] :volume_group 
    # @return [ApiCallRc]
    def volume_group_create(resource_group, opts = {})
      data, _status_code, _headers = volume_group_create_with_http_info(resource_group, opts)
      data
    end

    # add a volume-group to a resource-group
    # Adds a volume-group. 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeGroup] :volume_group 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_group_create_with_http_info(resource_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_group_create ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.volume_group_create"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}/volume-groups'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'volume_group'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_group_create",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_group_create\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # delete a volume-group
    # Delete a volume-group
    # @param resource_group [String] resource group to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @return [ApiCallRc]
    def volume_group_delete(resource_group, volume_number, opts = {})
      data, _status_code, _headers = volume_group_delete_with_http_info(resource_group, volume_number, opts)
      data
    end

    # delete a volume-group
    # Delete a volume-group
    # @param resource_group [String] resource group to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_group_delete_with_http_info(resource_group, volume_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_group_delete ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.volume_group_delete"
      end
      # verify the required parameter 'volume_number' is set
      if @api_client.config.client_side_validation && volume_number.nil?
        fail ArgumentError, "Missing the required parameter 'volume_number' when calling DevelopersApi.volume_group_delete"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}/volume-groups/{volume_number}'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s)).sub('{' + 'volume_number' + '}', CGI.escape(volume_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_group_delete",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_group_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # lists all volume-groups
    # Lists all volume groups.  A single volume group can be queried by adding its name to the resource string like:  /v1/resource-groups/rscgrp1/volume-groups/0 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<VolumeGroup>]
    def volume_group_list(resource_group, opts = {})
      data, _status_code, _headers = volume_group_list_with_http_info(resource_group, opts)
      data
    end

    # lists all volume-groups
    # Lists all volume groups.  A single volume group can be queried by adding its name to the resource string like:  /v1/resource-groups/rscgrp1/volume-groups/0 
    # @param resource_group [String] resource group to use
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset number of records to skip for pagination
    # @option opts [Integer] :limit maximum number of records to return
    # @return [Array<(Array<VolumeGroup>, Integer, Hash)>] Array<VolumeGroup> data, response status code and response headers
    def volume_group_list_with_http_info(resource_group, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_group_list ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.volume_group_list"
      end
      if @api_client.config.client_side_validation && !opts[:'offset'].nil? && opts[:'offset'] < 0
        fail ArgumentError, 'invalid value for "opts[:"offset"]" when calling DevelopersApi.volume_group_list, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.volume_group_list, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 0
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling DevelopersApi.volume_group_list, must be greater than or equal to 0.'
      end

      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}/volume-groups'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'offset'] = opts[:'offset'] if !opts[:'offset'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<VolumeGroup>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_group_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_group_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a resource-group
    # Sets or modifies properties  Possible properties are: - `StorPoolName` - regex[`^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$`]      Linstor storage pool name to use.  - `OverrideVlmId` - regex[`.*`]      Overwrites the generated '<resource-name>_<5 digit volume number>' volume name for migration purposes  - `AllowLargerVolumeSize` - boolean_true_false      Do not fail when the underlying volume is larger than expected  - `FileSystem/Type` - enum      File system type to use      * ext4     * xfs  - `FileSystem/MkfsParams` - string      Additional parameters for the mkfs command  - `StorDriver/LvcreateType` - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - `DrbdCurrentGi` - regex[`[a-fA-F0-9]{16}`] - `DrbdOptions/Disk/read-balancing` - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - `DrbdOptions/Disk/on-io-error` - enum     * pass_on     * call-local-io-error     * detach  - `DrbdOptions/Disk/disk-drain` - boolean - `DrbdOptions/Disk/resync-after` - string - `DrbdOptions/Disk/disk-timeout` - range[`0-6000`] - `DrbdOptions/Disk/disable-write-same` - boolean - `DrbdOptions/Disk/rs-discard-granularity` - range[`0-1048576`] - `DrbdOptions/Disk/disk-flushes` - boolean - `DrbdOptions/Disk/al-extents` - range[`67-65534`] - `DrbdOptions/Disk/al-updates` - boolean - `DrbdOptions/Disk/md-flushes` - boolean - `DrbdOptions/Disk/disk-barrier` - boolean - `DrbdOptions/Disk/discard-zeroes-if-aligned` - boolean 
    # @param resource_group [String] resource group to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeGroupModify] :volume_group_modify 
    # @return [ApiCallRc]
    def volume_group_modify(resource_group, volume_number, opts = {})
      data, _status_code, _headers = volume_group_modify_with_http_info(resource_group, volume_number, opts)
      data
    end

    # modify a resource-group
    # Sets or modifies properties  Possible properties are: - &#x60;StorPoolName&#x60; - regex[&#x60;^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,47}$&#x60;]      Linstor storage pool name to use.  - &#x60;OverrideVlmId&#x60; - regex[&#x60;.*&#x60;]      Overwrites the generated &#39;&lt;resource-name&gt;_&lt;5 digit volume number&gt;&#39; volume name for migration purposes  - &#x60;AllowLargerVolumeSize&#x60; - boolean_true_false      Do not fail when the underlying volume is larger than expected  - &#x60;FileSystem/Type&#x60; - enum      File system type to use      * ext4     * xfs  - &#x60;FileSystem/MkfsParams&#x60; - string      Additional parameters for the mkfs command  - &#x60;StorDriver/LvcreateType&#x60; - enum     * linear     * striped     * mirror     * raid0     * raid1     * raid4     * raid5     * raid6     * raid10     * lzma     * lz4  - &#x60;DrbdCurrentGi&#x60; - regex[&#x60;[a-fA-F0-9]{16}&#x60;] - &#x60;DrbdOptions/Disk/read-balancing&#x60; - enum     * prefer-local     * prefer-remote     * round-robin     * least-pending     * when-congested-remote     * 32K-striping     * 64K-striping     * 128K-striping     * 256K-striping     * 512K-striping     * 1M-striping  - &#x60;DrbdOptions/Disk/on-io-error&#x60; - enum     * pass_on     * call-local-io-error     * detach  - &#x60;DrbdOptions/Disk/disk-drain&#x60; - boolean - &#x60;DrbdOptions/Disk/resync-after&#x60; - string - &#x60;DrbdOptions/Disk/disk-timeout&#x60; - range[&#x60;0-6000&#x60;] - &#x60;DrbdOptions/Disk/disable-write-same&#x60; - boolean - &#x60;DrbdOptions/Disk/rs-discard-granularity&#x60; - range[&#x60;0-1048576&#x60;] - &#x60;DrbdOptions/Disk/disk-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/al-extents&#x60; - range[&#x60;67-65534&#x60;] - &#x60;DrbdOptions/Disk/al-updates&#x60; - boolean - &#x60;DrbdOptions/Disk/md-flushes&#x60; - boolean - &#x60;DrbdOptions/Disk/disk-barrier&#x60; - boolean - &#x60;DrbdOptions/Disk/discard-zeroes-if-aligned&#x60; - boolean 
    # @param resource_group [String] resource group to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeGroupModify] :volume_group_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_group_modify_with_http_info(resource_group, volume_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_group_modify ...'
      end
      # verify the required parameter 'resource_group' is set
      if @api_client.config.client_side_validation && resource_group.nil?
        fail ArgumentError, "Missing the required parameter 'resource_group' when calling DevelopersApi.volume_group_modify"
      end
      # verify the required parameter 'volume_number' is set
      if @api_client.config.client_side_validation && volume_number.nil?
        fail ArgumentError, "Missing the required parameter 'volume_number' when calling DevelopersApi.volume_group_modify"
      end
      # resource path
      local_var_path = '/v1/resource-groups/{resource_group}/volume-groups/{volume_number}'.sub('{' + 'resource_group' + '}', CGI.escape(resource_group.to_s)).sub('{' + 'volume_number' + '}', CGI.escape(volume_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'volume_group_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_group_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_group_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # modify a volume
    # Sets or modifies properties  Possible properties are: - `sys/fs/blkio_throttle_read` - number - `sys/fs/blkio_throttle_write` - number 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeModify] :volume_modify 
    # @return [ApiCallRc]
    def volume_modify(resource, node, volume_number, opts = {})
      data, _status_code, _headers = volume_modify_with_http_info(resource, node, volume_number, opts)
      data
    end

    # modify a volume
    # Sets or modifies properties  Possible properties are: - &#x60;sys/fs/blkio_throttle_read&#x60; - number - &#x60;sys/fs/blkio_throttle_write&#x60; - number 
    # @param resource [String] resource to use
    # @param node [String] node to use
    # @param volume_number [Integer] 
    # @param [Hash] opts the optional parameters
    # @option opts [VolumeModify] :volume_modify 
    # @return [Array<(ApiCallRc, Integer, Hash)>] ApiCallRc data, response status code and response headers
    def volume_modify_with_http_info(resource, node, volume_number, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DevelopersApi.volume_modify ...'
      end
      # verify the required parameter 'resource' is set
      if @api_client.config.client_side_validation && resource.nil?
        fail ArgumentError, "Missing the required parameter 'resource' when calling DevelopersApi.volume_modify"
      end
      # verify the required parameter 'node' is set
      if @api_client.config.client_side_validation && node.nil?
        fail ArgumentError, "Missing the required parameter 'node' when calling DevelopersApi.volume_modify"
      end
      # verify the required parameter 'volume_number' is set
      if @api_client.config.client_side_validation && volume_number.nil?
        fail ArgumentError, "Missing the required parameter 'volume_number' when calling DevelopersApi.volume_modify"
      end
      # resource path
      local_var_path = '/v1/resource-definitions/{resource}/resources/{node}/volumes/{volume_number}'.sub('{' + 'resource' + '}', CGI.escape(resource.to_s)).sub('{' + 'node' + '}', CGI.escape(node.to_s)).sub('{' + 'volume_number' + '}', CGI.escape(volume_number.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'volume_modify'])

      # return_type
      return_type = opts[:debug_return_type] || 'ApiCallRc'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DevelopersApi.volume_modify",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DevelopersApi#volume_modify\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
